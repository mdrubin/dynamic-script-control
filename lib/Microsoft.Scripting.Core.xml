<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Scripting.Core</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Scripting.Utils.CheckedDictionaryEnumerator">
            <summary>
            Not all .NET enumerators throw exceptions if accessed in an invalid state. This type
            can be used to throw exceptions from enumerators implemented in IronPython.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.IAttributesCollection">
            <summary>
            This interface represents a dictionary that can be accessed using symbols and also arbitrary objects.
            This should conceptually inherit from IDictionary&lt;object, object&gt;, but we do not do that as we want the default indexer
            property to be indexed by SymbolId, not by object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.IAttributesCollection.Add(Microsoft.Scripting.SymbolId,System.Object)">
            
             Access using SymbolId keys
            
        </member>
        <member name="T:Microsoft.Scripting.TextContentProvider">
            <summary>
            Provides a factory to create TextReader's over one source of textual content.
            
            TextContentProvider's are used when reading from a source which is already decoded
            or has a known specific decoding.  
            
            For example a text editor might provide a TextContentProvider whose backing is
            an in-memory text buffer that the user can actively edit.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.TextContentProvider.GetReader">
            <summary>
            Creates a new TextReader which is backed by the content the TextContentProvider was created for.
            
            This method may be called multiple times.  For example once to compile the code and again to get
            the source code to display error messages.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.IModuleDictionaryInitialization">
            <summary>
            Intended for internal use to initialization optimized module dictionaries.  Exposed publicly because 
            generated types implement this interface.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.GlobalsDictionary">
            <summary>
            Dictionary backed by an array used for collectable globals. See also
            GlobalArrayRewriter
            
            TODO: move to Microsoft.Scripting
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.CustomSymbolDictionary">
            <summary>
            Abstract base class used for optimized thread-safe SymbolDictionaries. 
            
            Implementers derive from this class and override the GetExtraKeys, TrySetExtraValue, 
            and TryGetExtraValue methods. When looking up a value first the extra keys will be 
            searched using the optimized Try*ExtraValue functions.  If the value isn't found there
            then the value is stored in the underlying .NET dictionary.
            
            Implementors can optionally override the object key functionality to store object keys
            using their own mechanism.  By default object keys are stored in their own dictionary
            which is stored in the primary SymbolId dictionary under an invalid symbol id.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.BaseSymbolDictionary">
            <summary>
            Base class for SymbolId dictionaries.  
            
            SymbolId dictionaries are fast dictionaries used for looking up members of classes, 
            function environments, function locals, and other places which are typically indexed by 
            string names.  
            
            SymbolId dictionaries support both keying by SymbolId (the common case) and object keys 
            (supporting late bound access to the dictionary as a normal Dictionary&lt;object, object&gt; 
            when exposed directly to user code).  When indexed by objects null is a valid value for the
            key.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.IValueEquality">
            <summary>
            Provides hashing and equality based upon the value of the object instead of the reference.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.IValueEquality.GetValueHashCode">
            <summary>
            Gets the hash code for the value of the instance.
            </summary>
            <returns>A hash code</returns>
            <exception cref="T:Microsoft.Scripting.ArgumentTypeException">The type is mutable and cannot be hashed by value</exception>
        </member>
        <member name="M:Microsoft.Scripting.IValueEquality.ValueEquals(System.Object)">
            <summary>
            Determines if two values are equal
            </summary>
            <param name="other">The object to compare the current object against.</param>
            <returns>Returns true if the objects are equal, false if they are not.</returns>        
        </member>
        <member name="M:Microsoft.Scripting.Runtime.BaseSymbolDictionary.#ctor">
            <summary>
            Creates a new SymbolIdDictBase from the specified creating context which will be
            used for comparisons.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomSymbolDictionary.GetExtraKeys">
            <summary>
            Gets a list of the extra keys that are cached by the the optimized implementation
            of the module.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomSymbolDictionary.TrySetExtraValue(Microsoft.Scripting.SymbolId,System.Object)">
            <summary>
            Try to set the extra value and return true if the specified key was found in the 
            list of extra values.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomSymbolDictionary.TryGetExtraValue(Microsoft.Scripting.SymbolId,System.Object@)">
            <summary>
            Try to get the extra value and returns true if the specified key was found in the
            list of extra values.  Returns true even if the value is Uninitialized.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomSymbolDictionary.GetObjectKeysDictionary">
            <summary>
            Field dictionaries are usually indexed using literal strings, which is handled using the Symbols.
            However, Python does allow non-string keys too. We handle this case by lazily creating an object-keyed dictionary,
            and keeping it in the symbol-indexed dictionary. Such access is slower, which is acceptable.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomSymbolDictionary.GetObjectKeys(System.Collections.Generic.List{System.Object})">
            <summary>
            Appends the object keys to the provided list.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomSymbolDictionary.GetObjectValues(System.Collections.Generic.List{System.Object})">
            <summary>
            Appends the values stored under object keys to the provided list.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomSymbolDictionary.GetObjectKeyCount">
            <summary>
            Gets the count of object keys.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomSymbolDictionary.GetObjectItems">
            <summary>
            Gets an IDictionaryEnumerator for all of the object key/value pairs.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomSymbolDictionary.AddObjectKey(System.Object,System.Object)">
            <summary>
            Stores the specified value under the specified object key.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomSymbolDictionary.RemoveObjectKey(System.Object)">
            <summary>
            Removes the specified object key from the dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomSymbolDictionary.TryGetObjectValue(System.Object,System.Object@)">
            <summary>
            Attemps to get the value stored under the specified object key.
            
            Returns true if the key was found, false if not found.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.SourceLocation">
            <summary>
            Represents a location in source code.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new source location.
            </summary>
            <param name="index">The index in the source stream the location represents (0-based).</param>
            <param name="line">The line in the source stream the location represents (1-based).</param>
            <param name="column">The column in the source stream the location represents (1-based).</param>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.op_Equality(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Compares two specified location values to see if they are equal.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the locations are the same, False otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.op_Inequality(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Compares two specified location values to see if they are not equal.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the locations are not the same, False otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.op_LessThan(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Compares two specified location values to see if one is before the other.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the first location is before the other location, False otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.op_GreaterThan(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Compares two specified location values to see if one is after the other.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the first location is after the other location, False otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.op_LessThanOrEqual(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Compares two specified location values to see if one is before or the same as the other.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the first location is before or the same as the other location, False otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.op_GreaterThanOrEqual(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Compares two specified location values to see if one is after or the same as the other.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the first location is after or the same as the other location, False otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.Compare(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Compares two specified location values.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>0 if the locations are equal, -1 if the left one is less than the right one, 1 otherwise.</returns>
        </member>
        <member name="F:Microsoft.Scripting.SourceLocation.None">
            <summary>
            A location that is valid but represents no location at all.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceLocation.Invalid">
            <summary>
            An invalid location.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceLocation.MinValue">
            <summary>
            A minimal valid location.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceLocation.Index">
            <summary>
            The index in the source stream the location represents (0-based).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceLocation.Line">
            <summary>
            The line in the source stream the location represents (1-based).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceLocation.Column">
            <summary>
            The column in the source stream the location represents (1-based).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceLocation.IsValid">
            <summary>
            Whether the location is a valid location.
            </summary>
            <returns>True if the location is valid, False otherwise.</returns>
        </member>
        <member name="T:Microsoft.Scripting.Generation.GlobalStaticFieldRewriter">
            <summary>
            Rewrites globals to static fields on a type
            TODO: move to Microsoft.Scripting
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.GlobalRewriter">
            <summary>
            Rewrites known extension nodes into primitive ones:
              * GlobalVariableExpression
              * CodeContextExpression
              * CodeContextSCope
              
            TODO: move to Microsoft.Scripting
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.DynamicNodeRewriter">
            <summary>
            Walks the DLR tree and reduces dynamic AST nodes
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.TreeRewriter">
            <summary>
            Base class for rewriting trees.  Subclasses can override individual Rewrite methods from which they can
            return rewritten nodes.  The TreeRewritter will handle the propagation up the tree of all the changed
            nodes.
            
            Only nodes which are unchanged will be re-written.  To force processing of a node subclasses can call RewriteNode
            directly.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.TreeRewriter.RewriteArray(System.Collections.Generic.IList{Microsoft.Scripting.Ast.Expression})">
            <summary>
            Helper to re-write an array of arguments.  Returns null if none of the
            children are rewritten or the new array containing both re-written and
            non re-written nodes.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.ArgSlot">
            <summary>
            Argument access
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.Slot">
            <summary>
            Slot refers to a reference to an object. For eg, a global variable, a local variable, etc.
            A Slot is referred to using a Name. The Namespace is used to map a Name to a Slot.
            Multiple Names can refer to the same Slot.
            For eg. multiple closures can refer to the same Slot of a local variable in the enclosing
            function. Though each closure will use the same string (the name of the variable), each
            string is considered a unique Name or symbol.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.Expression">
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            TODO: move to Microsoft.Scripting !!!
            </summary>
            <summary>
            Factory methods.
            TODO: review which of these overloads we actually need
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            TODO: move to Microsoft.Scripting !!!
            </summary>
            <summary>
            Factory methods
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Summary description for Expr.
            </summary>
            <summary>
            Factory methods.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Call(System.Type,Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Actions.InvokeMemberAction,Microsoft.Scripting.Ast.Expression[])">
            <summary>
            A dynamic or unbound method call
            </summary>
            <param name="returnType">the type that the method returns, or null for an unbound node</param>
            <param name="instance">the instance to call; must be non-null</param>
            <param name="bindingInfo">call binding information (method name, named arguments, etc)</param>
            <param name="arguments">the arguments to the call</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Call(System.Type,Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Actions.InvokeMemberAction,Microsoft.Scripting.Ast.Annotations,System.Collections.Generic.IEnumerable{Microsoft.Scripting.Ast.Expression})">
            <summary>
            A dynamic or unbound method call
            </summary>
            <param name="returnType">the type that the method returns, or null for an unbound node</param>
            <param name="instance">the instance to call; must be non-null</param>
            <param name="bindingInfo">call binding information (method name, named arguments, etc)</param>
            <param name="annotations">annotations for the node</param>
            <param name="arguments">the arguments to the call</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.SimpleCallHelper(System.Reflection.MethodInfo,Microsoft.Scripting.Ast.Expression[])">
            <summary>
            The helper to create the AST method call node. Will add conversions (Expression.Convert())
            to parameters and instance if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.SimpleCallHelper(Microsoft.Scripting.Ast.Expression,System.Reflection.MethodInfo,Microsoft.Scripting.Ast.Expression[])">
            <summary>
            The helper to create the AST method call node. Will add conversions (Expression.Convert())
            to parameters and instance if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.ComplexCallHelper(System.Reflection.MethodInfo,Microsoft.Scripting.Ast.Expression[])">
            <summary>
            The complex call helper to create the AST method call node.
            Will add conversions (Expression.Convert()), deals with default parameter values and params arrays.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.GetMember(Microsoft.Scripting.Ast.Expression,System.Type,Microsoft.Scripting.Actions.CallSiteBinder)">
            <summary>
            A dynamic or unbound get member
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.GetLambdaSignature(Microsoft.Scripting.Ast.LambdaExpression)">
            <summary>
            Extracts the signature of the LambdaExpression as an array of Types
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.ValidateDelegateType(Microsoft.Scripting.Ast.LambdaExpression,System.Type)">
            <summary>
            Validates that the delegate type of the lambda
            matches the lambda itself.
            
            * Return types of the lambda and the delegate must be identical.
            
            * Without parameter array on the delegate type, the signatures must
              match perfectly as to count and types of parameters.
              
            * With parameter array on the delegate type, the common subset of
              parameters must match
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Convert(Microsoft.Scripting.Ast.Expression,System.Type,Microsoft.Scripting.Actions.CallSiteBinder)">
            <summary>
            A dynamic or unbound conversion
            </summary>
            <param name="expression">the expression to convert</param>
            <param name="type">the type that the conversion returns, or null for an unbound node</param>
            <param name="bindingInfo">convert binding information</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.WeakConstant(System.Object)">
            <summary>
            Wraps the given value in a WeakReference and returns a tree that will retrieve
            the value from the WeakReference.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Block(System.Collections.Generic.IEnumerable{Microsoft.Scripting.Ast.Expression})">
            <summary>
            Creates a list of expressions whose value is void.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Comma(System.Collections.Generic.IEnumerable{Microsoft.Scripting.Ast.Expression})">
            <summary>
            Creates a list of expressions whose value is the value of the last expression.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Invoke(Microsoft.Scripting.Ast.Annotations,System.Type,Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Actions.CallAction,Microsoft.Scripting.Ast.Expression[])">
            <summary>
            A dynamic or unbound invoke
            </summary>
            <param name="annotations">annotations for the node</param>
            <param name="returnType">the type that the method returns, or null for an unbound node</param>
            <param name="expression">the callable object to call; must be non-null</param>
            <param name="bindingInfo">invoke binding information (method name, named arguments, etc)</param>
            <param name="arguments">the arguments to the call</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.ArrayIndex(Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.Expression)">
            <summary>
            Creates a binary expression representing array indexing: array[index]
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Add(Microsoft.Scripting.Ast.Annotations,Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.Expression,System.Type,Microsoft.Scripting.Actions.CallSiteBinder)">
            <summary>
            Adds two arithmetic values of the same type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Subtract(Microsoft.Scripting.Ast.Annotations,Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.Expression,System.Type,Microsoft.Scripting.Actions.CallSiteBinder)">
            <summary>
            Subtracts two arithmetic values of the same type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Divide(Microsoft.Scripting.Ast.Annotations,Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.Expression,System.Type,Microsoft.Scripting.Actions.CallSiteBinder)">
            <summary>
            Divides two arithmetic values of the same type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Modulo(Microsoft.Scripting.Ast.Annotations,Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.Expression,System.Type,Microsoft.Scripting.Actions.CallSiteBinder)">
            <summary>
            Modulos two arithmetic values of the same type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Multiply(Microsoft.Scripting.Ast.Annotations,Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.Expression,System.Type,Microsoft.Scripting.Actions.CallSiteBinder)">
            <summary>
            Multiples two arithmetic values of the same type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.LeftShift(Microsoft.Scripting.Ast.Annotations,Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.Expression,System.Type,Microsoft.Scripting.Actions.CallSiteBinder)">
            <summary>
            Left shifts one arithmetic value by another aritmetic value of the same type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.RightShift(Microsoft.Scripting.Ast.Annotations,Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.Expression,System.Type,Microsoft.Scripting.Actions.CallSiteBinder)">
            <summary>
            Right shifts one arithmetic value by another aritmetic value of the same type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.And(Microsoft.Scripting.Ast.Annotations,Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.Expression,System.Type,Microsoft.Scripting.Actions.CallSiteBinder)">
            <summary>
            Performs bitwise and of two values of the same type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Or(Microsoft.Scripting.Ast.Annotations,Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.Expression,System.Type,Microsoft.Scripting.Actions.CallSiteBinder)">
            <summary>
            Performs bitwise or of two values of the same type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.ExclusiveOr(Microsoft.Scripting.Ast.Annotations,Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.Expression,System.Type,Microsoft.Scripting.Actions.CallSiteBinder)">
            <summary>
            Performs exclusive or of two values of the same type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Reduce">
            <summary>
            Reduces this node to a simpler expression. If IsReducible returns
            true, this should return a valid expression. This method is
            allowed to return another node which itself must be reduced.
            </summary>
            <returns>the reduced expression</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.RequiresBound(Microsoft.Scripting.Ast.Expression,System.String)">
            <summary>
            Verifies that the expression is fully bound (i.e. it has a non-null type)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.RequiresBoundItems(System.Collections.Generic.IList{Microsoft.Scripting.Ast.Expression},System.String)">
            <summary>
            Verifies that all expressions in the list are fully bound
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.ReduceToKnown(Microsoft.Scripting.Ast.Expression)">
            <summary>
            Reduces the expression to a known node type (i.e. not an Extension node)
            or simply returns the expression if it is already a known type
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.NewArrayInit(System.Type,Microsoft.Scripting.Ast.Expression[])">
            <summary>
            Creates a new array expression of the specified type from the provided initializers.
            </summary>
            <param name="type">The type of the array (e.g. object[]).</param>
            <param name="initializers">The expressions used to create the array elements.</param>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{Microsoft.Scripting.Ast.Expression})">
            <summary>
            Creates a new array expression of the specified type from the provided initializers.
            </summary>
            <param name="type">The type of the array (e.g. object[]).</param>
            <param name="initializers">The expressions used to create the array elements.</param>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Assign(Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.Annotations)">
            <summary>
            Performs an assignment variable = value
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.AssignField(Microsoft.Scripting.Ast.Expression,System.Reflection.FieldInfo,Microsoft.Scripting.Ast.Expression)">
            <summary>
            Creates MemberExpression representing field access, instance or static.
            For static field, expression must be null and FieldInfo.IsStatic == true
            For instance field, expression must be non-null and FieldInfo.IsStatic == false.
            </summary>
            <param name="expression">Expression that evaluates to the instance for the field access.</param>
            <param name="field">Field represented by this Member expression.</param>
            <param name="value">Value to set this field to.</param>
            <returns>New instance of Member expression</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.AssignProperty(Microsoft.Scripting.Ast.Expression,System.Reflection.PropertyInfo,Microsoft.Scripting.Ast.Expression)">
            <summary>
            Creates MemberExpression representing property access, instance or static.
            For static properties, expression must be null and property.IsStatic == true.
            For instance properties, expression must be non-null and property.IsStatic == false.
            </summary>
            <param name="expression">Expression that evaluates to the instance for instance property access.</param>
            <param name="property">PropertyInfo of the property to access</param>
            <param name="value">Value to set this property to.</param>
            <returns>New instance of the MemberExpression.</returns>
        </member>
        <member name="P:Microsoft.Scripting.Ast.Expression.BindingInfo">
            <summary>
            Information that can be used to bind this tree,
            either statically or dynamically
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.Expression.IsBound">
            <summary>
            Returns true if the tree is fully bound, i.e. Type is not null
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.Expression.IsDynamic">
            <summary>
            Returns true if this tree is dynamically bound, i.e.
            Type is not null and BindingInfo is not null
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.Expression.IsReducible">
            <summary>
            Indicates that the node can be reduced to a simpler node. If this 
            returns true, Reduce() can be called to produce the reduced form.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Action.Operator(Microsoft.Scripting.Actions.ActionBinder,Microsoft.Scripting.Runtime.Operators,System.Type,Microsoft.Scripting.Ast.Expression[])">
            <summary>
            Creates ActionExpression representing DoOperationAction.
            </summary>
            <param name="binder">The binder responsible for binding the dynamic operation.</param>
            <param name="op">The operation to perform</param>
            <param name="result">Type of the result desired (The ActionExpression is strongly typed)</param>
            <param name="arguments">Array of arguments for the action expression</param>
            <returns>New instance of the ActionExpression</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Action.GetMember(Microsoft.Scripting.Actions.ActionBinder,System.String,System.Type,Microsoft.Scripting.Ast.Expression)">
            <summary>
            Creates ActionExpression representing a GetMember action.
            </summary>
            <param name="binder">The binder responsible for binding the dynamic operation.</param>
            <param name="name">The qualifier.</param>
            <param name="result">Type of the result desired (The ActionExpression is strongly typed)</param>
            <param name="expression">the instance expression</param>
            <returns>New instance of the ActionExpression</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Action.GetMember(Microsoft.Scripting.Actions.ActionBinder,System.String,Microsoft.Scripting.Actions.GetMemberBindingFlags,System.Type,Microsoft.Scripting.Ast.Expression)">
            <summary>
            Creates ActionExpression representing a GetMember action.
            </summary>
            <param name="binder">The binder responsible for binding the dynamic operation.</param>
            <param name="name">The qualifier.</param>
            <param name="result">Type of the result desired (The ActionExpression is strongly typed)</param>
            <param name="expression">the instance expression</param>
            <param name="getMemberFlags">The binding flags for the get operation</param>
            <returns>New instance of the ActionExpression</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Action.SetMember(Microsoft.Scripting.Actions.ActionBinder,System.String,System.Type,Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.Expression)">
            <summary>
            Creates ActionExpression representing a SetMember action.
            </summary>
            <param name="binder">The binder responsible for binding the dynamic operation.</param>
            <param name="name">The qualifier.</param>
            <param name="result">Type of the result desired (The ActionExpression is strongly typed)</param>
            <param name="expression">Target of the set member expression</param>
            <param name="value">The value to set</param>
            <returns>New instance of the ActionExpression</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Action.Call(Microsoft.Scripting.Actions.CallAction,System.Type,Microsoft.Scripting.Ast.Expression[])">
            <summary>
            Creates ActionExpression representing a Call action.
            </summary>
            <param name="action">The call action to perform.</param>
            <param name="result">Type of the result desired (The ActionExpression is strongly typed)</param>
            <param name="arguments">Array of arguments for the action expression</param>
            <returns>New instance of the ActionExpression</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Action.Create(Microsoft.Scripting.Actions.CreateInstanceAction,System.Type,Microsoft.Scripting.Ast.Expression[])">
            <summary>
            Creates ActionExpression representing a CreateInstance action.
            </summary>
            <param name="action">The create instance action to perform.</param>
            <param name="result">Type of the result desired (The ActionExpression is strongly typed)</param>
            <param name="arguments">Array of arguments for the action expression</param>
            <returns>New instance of the ActionExpression</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Action.ConvertTo(Microsoft.Scripting.Actions.CallSiteBinder,Microsoft.Scripting.Ast.Expression,System.Type)">
            <summary>
            Creates a new ActionExpression which performs a conversion.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Action.ConvertTo(Microsoft.Scripting.Actions.ConvertToAction,Microsoft.Scripting.Ast.Expression)">
            <summary>
            Creates a new ActionExpression which performs the specified conversion and returns the strongly typed result.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Action.ConvertTo(Microsoft.Scripting.Actions.ActionBinder,System.Type,Microsoft.Scripting.Ast.Expression)">
            <summary>
            Creates a new ActionExpression which performs the specified conversion to the type.  The ActionExpression
            is strongly typed to the provided type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Action.ConvertTo(Microsoft.Scripting.Actions.ActionBinder,System.Type,Microsoft.Scripting.Actions.ConversionResultKind,Microsoft.Scripting.Ast.Expression)">
            <summary>
            Creates a new ActionExpressoin which performs the specified conversion to the type.  The ActionExpress
            is strongly typed to the converted type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Action.ConvertTo(Microsoft.Scripting.Actions.ActionBinder,System.Type,Microsoft.Scripting.Actions.ConversionResultKind,Microsoft.Scripting.Ast.Expression[])">
            <summary>
            Creates a new ActionExpressoin which performs the specified conversion to the type.  The ActionExpress
            is strongly typed to the converted type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Expression.Action.ConvertTo(Microsoft.Scripting.Actions.ActionBinder,System.Type,Microsoft.Scripting.Actions.ConversionResultKind,Microsoft.Scripting.Ast.Expression,System.Type)">
            <summary>
            Creates a new ActionExpression which performs the conversion to the specified type with the 
            specified conversion kind.  The ActionExpression is strongly typed to the provided
            actionExpressionType.
            </summary>
            <param name="binder">The binder responsible for binding the dynamic operation.</param>
            <param name="toType">The type to convert to</param>
            <param name="actionExpressionType">The return type for the ActionExpression (should be assignable from the toType)</param>
            <param name="kind">The kind of conversion to preform</param>
            <param name="argument">The argument to be converted</param>
        </member>
        <member name="T:Microsoft.Scripting.Ast.ArgumentKind">
            <summary>
            Convention for an individual argument at a callsite.
            
            Multiple different callsites can match against a single declaration. 
            Some argument kinds can be "unrolled" into multiple arguments, such as list and dictionary. 
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.ArgumentKind.Simple">
            <summary>
            Simple unnamed positional argument.
            In Python: foo(1,2,3) are all simple arguments.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.ArgumentKind.Named">
            <summary>
            Argument with associated name at the callsite
            In Python: foo(a=1)
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.ArgumentKind.List">
            <summary>
            Argument containing a list of arguments. 
            In Python: foo(*(1,2*2,3))  would match 'def foo(a,b,c)' with 3 declared arguments such that (a,b,c)=(1,4,3).
                 it could also match 'def foo(*l)' with 1 declared argument such that l=(1,4,3)
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.ArgumentKind.Dictionary">
            <summary>
            Argument containing a dictionary of named arguments.
            In Python: foo(**{'a':1, 'b':2})
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginCatchBlock(System.Type)">
            <summary>
            Begins a catch block.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginExceptFilterBlock">
            <summary>
            Begins an exception block for a filtered exception.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginExceptionBlock">
            <summary>
            Begins an exception block for a non-filtered exception.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginFaultBlock">
            <summary>
            Begins an exception fault block
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginFinallyBlock">
            <summary>
            Begins a finally block
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EndExceptionBlock">
            <summary>
            Ends an exception block.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginScope">
            <summary>
            Begins a lexical scope.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EndScope">
            <summary>
            Ends a lexical scope.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.DeclareLocal(System.Type)">
            <summary>
            Declares a local variable of the specified type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.DeclareLocal(System.Type,System.Boolean)">
            <summary>
            Declares a local variable of the specified type, optionally
            pinning the object referred to by the variable.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.DefineLabel">
            <summary>
            Declares a new label.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.MarkLabel(System.Reflection.Emit.Label)">
            <summary>
            Marks the label at the current position.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode)">
            <summary>
            Emits an instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Byte)">
            <summary>
            Emits an instruction with a byte argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.ConstructorInfo)">
            <summary>
            Emits an instruction with the metadata token for the specified contructor.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Double)">
            <summary>
            Emits an instruction with a double argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.FieldInfo)">
            <summary>
            Emits an instruction with the metadata token for the specified field.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Single)">
            <summary>
            Emits an instruction with a float argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Int32)">
            <summary>
            Emits an instruction with an int argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label)">
            <summary>
            Emits an instruction with a label argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label[])">
            <summary>
            Emits an instruction with multiple target labels (switch).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.LocalBuilder)">
            <summary>
            Emits an instruction with a reference to a local variable.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Int64)">
            <summary>
            Emits an instruction with a long argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo)">
            <summary>
            Emits an instruction with the metadata token for a specified method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.SByte)">
            <summary>
            Emits an instruction with a signed byte argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Int16)">
            <summary>
            Emits an instruction with a short argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.SignatureHelper)">
            <summary>
            Emits an instruction with a signature token.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.String)">
            <summary>
            Emits an instruction with a string argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Type)">
            <summary>
            Emits an instruction with the metadata token for a specified type argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitCall(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo,System.Type[])">
            <summary>
            Emits a call or a virtual call to the varargs method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitCalli(System.Reflection.Emit.OpCode,System.Runtime.InteropServices.CallingConvention,System.Type,System.Type[])">
            <summary>
            Emits an unmanaged indirect call instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitCalli(System.Reflection.Emit.OpCode,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])">
            <summary>
            Emits a managed indirect call instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.MarkSequencePoint(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Marks a sequence point.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.UsingNamespace(System.String)">
            <summary>
            Specifies the namespace to be used in evaluating locals and watches for the
                current active lexical scope.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitLoadValueIndirect(System.Type)">
            <summary>
            Emits a Ldind* instruction for the appropriate type
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitStoreValueIndirect(System.Type)">
            <summary>
            Emits a Stind* instruction for the appropriate type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitLoadElement(System.Type)">
            <summary>
            Emits the Ldelem* instruction for the appropriate type
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitStoreElement(System.Type)">
            <summary>
            Emits a Stelem* instruction for the appropriate type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitBoxing(System.Type)">
            <summary>
            Boxes the value of the stack. No-op for reference types.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitArray``1(System.Collections.Generic.IList{``0})">
            <summary>
            Emits an array of constant values provided in the given list.
            The array is strongly typed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitArray(System.Type,System.Int32,Microsoft.Scripting.Generation.EmitArrayHelper)">
            <summary>
            Emits an array of values of count size.  The items are emitted via the callback
            which is provided with the current item index to emit.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitArray(System.Type)">
            <summary>
            Emits an array construction code.  
            The code assumes that bounds for all dimensions
            are already emitted.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitDefault(System.Type)">
            <summary>
            Emits default(T)
            Semantics match C# compiler behavior
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitSymbolId(Microsoft.Scripting.SymbolId)">
            <summary>
            Emits a symbol id.  
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.AstWriter.Dump(Microsoft.Scripting.Ast.Expression,System.String)">
            <summary>
            Write out the given AST (only if ShowTrees or DumpTrees is enabled)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.AstWriter.Dump``1(Microsoft.Scripting.Actions.Rule{``0})">
            <summary>
            Write out the given rule's AST (only if ShowRules is enabled)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.AstWriter.Dump(Microsoft.Scripting.Ast.Expression,System.String,System.IO.TextWriter)">
            <summary>
            Write out the given AST
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.MemberTracker">
            <summary>
            Represents a logical member of a type.  The member could either be real concrete member on a type or
            an extension member.
            
            This seperates the "physical" members that .NET knows exist on types from the members that
            logically exist on a type.  It also provides other abstractions above the level of .NET reflection
            such as MemberGroups and NamespaceTracker's.
            
            It also provides a wrapper around the reflection APIs which cannot be extended from partial trust.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.GetValue(Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Actions.ActionBinder,System.Type)">
            <summary>
            Gets the expression that creates the value.  
            
            Returns null if it's an error to get the value.  The caller can then call GetErrorForGet to get 
            the correct error Expression (or null if they should provide a default).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.SetValue(Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Actions.ActionBinder,System.Type,Microsoft.Scripting.Ast.Expression)">
            <summary>
            Gets an expression that assigns a value to the left hand side.
            
            Returns null if it's an error to assign to.  The caller can then call GetErrorForSet to
            get the correct error Expression (or null if a default error should be provided).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.Call(Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Actions.ActionBinder,Microsoft.Scripting.Ast.Expression[])">
            <summary>
            Gets an expression that performs a call on the object using the specified arguments.
            
            Returns null if it's an error to perform the specific operation.  The caller can then call 
            GetErrorsForDoCall to get the correct error Expression (or null if a default error should be provided).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.GetError(Microsoft.Scripting.Actions.ActionBinder)">
            <summary>
            Returns the error associated with getting the value.  
            
            A null return value indicates that the default error message should be provided by the caller.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.GetBoundError(Microsoft.Scripting.Actions.ActionBinder,Microsoft.Scripting.Ast.Expression)">
            <summary>
            Returns the error associated with accessing this member via a bound instance.
            
            A null return value indicates that the default error message should be provided by the caller.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.GetBoundValue(Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Actions.ActionBinder,System.Type,Microsoft.Scripting.Ast.Expression)">
            <summary>
            Helper for getting values that have been bound.  Called from BoundMemberTracker.  Custom member
            trackers can override this to provide their own behaviors when bound to an instance.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.SetBoundValue(Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Actions.ActionBinder,System.Type,Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.Expression)">
            <summary>
            Helper for setting values that have been bound.  Called from BoundMemberTracker.  Custom member
            trackers can override this to provide their own behaviors when bound to an instance.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.BindToInstance(Microsoft.Scripting.Ast.Expression)">
            <summary>
            Binds the member tracker to the specified instance rturning a new member tracker if binding 
            is possible.  If binding is not possible the existing member tracker will be returned.  For example
            binding to a static field results in returning the original MemberTracker.  Binding to an instance
            field results in a new BoundMemberTracker which will get GetBoundValue/SetBoundValue to pass the
            instance through.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.MemberTracker.MemberType">
            <summary>
            The type of member tracker.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.MemberTracker.DeclaringType">
            <summary>
            The logical declaring type of the member.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.MemberTracker.Name">
            <summary>
            The name of the member.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.MemberTracker.MemberKey">
            <summary>
            We ensure we only produce one MemberTracker for each member which logically lives on the declaring type.  So 
            for example if you get a member from a derived class which is declared on the base class it should be the same 
            as getting the member from the base class.  That?s easy enough until you get into extension members ? here there
            might be one extension member which is being applied to multiple types.  Therefore we need to take into account the 
            extension type when ensuring that we only have 1 MemberTracker ever created.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.IMembersList">
            <summary>
            Provides a list of all the members of an instance.  ie. all the keys in the 
            dictionary of the object. Note that it can contain objects that are not strings. 
            
            Such keys can be added in IronPython using syntax like:
                obj.__dict__[100] = someOtherObject
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TypeTracker.op_Implicit(Microsoft.Scripting.Actions.TypeTracker)~System.Type">
            <summary>
            Enables implicit Type to TypeTracker conversions accross dynamic languages.
            
            TODO: Should be explicit, but that breaks a JS test
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.CallSiteBinder">
            <summary>
            Class responsible for binding dynamic operations on the dynamic site.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.CallSiteBinder.Bind``1(System.Object[])">
            <summary>
            The bind call to produce the binding.
            </summary>
            <typeparam name="T">Delegate type</typeparam>
            <param name="args">Array of arguments to the call</param>
            <returns>New rule.</returns>
        </member>
        <member name="P:Microsoft.Scripting.Actions.CallSiteBinder.HashCookie">
            <summary>
            Key used for the DLR caching
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.IExpressionSerializable">
            <summary>
            Enables an object to be serializable to an Expression tree.  The expression tree can then
            be emitted into an assembly enabling the de-serialization of the object.
            
            TODO: move to Microsoft.Scripting !!!
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComDispatch.IDispatchComObject">
            <summary>
            An object that implements IDispatch
            
            This currently has the following issues:
            1. If we prefer ComObjectWithTypeInfo over IDispatchObject, then we will often not
               IDispatchObject since implementations of IDispatch often rely on a registered type library. 
               If we prefer IDispatchObject over ComObjectWithTypeInfo, users get a non-ideal experience.
            2. IDispatch cannot distinguish between properties and methods with 0 arguments (and non-0 
               default arguments?). So obj.foo() is ambiguous as it could mean invoking method foo, 
               or it could mean invoking the function pointer returned by property foo.
               We are attempting to find whether we need to call a method or a property by examining
               the ITypeInfo associated with the IDispatch. ITypeInfo tell's use what parameters the method
               expects, is it a method or a property, what is the default property of the object, how to 
               create an enumerator for collections etc.
            3. IronPython processes the signature and converts ref arguments into return values. 
               However, since the signature of a DispMethod is not available beforehand, this conversion 
               is not possible. There could be other signature conversions that may be affected. How does 
               VB6 deal with ref arguments and IDispatch?
               
            We also support events for IDispatch objects:
            Background:
            COM objects support events through a mechanism known as Connect Points.
            Connection Points are separate objects created off the actual COM 
            object (this is to prevent circular references between event sink
            and event source). When clients want to sink events generated  by 
            COM object they would implement callback interfaces (aka source 
            interfaces) and hand it over (advise) to the Connection Point. 
            
            Implementation details:
            When IDispatchObject.TryGetMember request is received we first check
            whether the requested member is a property or a method. If this check
            fails we will try to determine whether an event is requested. To do 
            so we will do the following set of steps:
            1. Verify the COM object implements IConnectionPointContainer
            2. Attempt to find COM object's coclass's description
               a. Query the object for IProvideClassInfo interface. Go to 3, if found
               b. From object's IDispatch retrieve primary interface description
               c. Scan coclasses declared in object's type library.
               d. Find coclass implementing this particular primary interface 
            3. Scan coclass for all its source interfaces.
            4. Check whether to any of the methods on the source interfaces matches 
            the request name
            
            Once we determine that TryGetMember requests an event we will return
            an instance of BoundDispEvent class. This class has InPlaceAdd and
            InPlaceSubtract operators defined. Calling InPlaceAdd operator will:
            1. An instance of ComEventSinksContainer class is created (unless 
            RCW already had one). This instance is hanged off the RCW in attempt
            to bind the lifetime of event sinks to the lifetime of the RCW itself,
            meaning event sink will be collected once the RCW is collected (this
            is the same way event sinks lifetime is controlled by PIAs).
            Notice: ComEventSinksContainer contains a Finalizer which will go and
            unadvise all event sinks.
            Notice: ComEventSinksContainer is a list of ComEventSink objects. 
            2. Unless we have already created a ComEventSink for the required 
            source interface, we will create and advise a new ComEventSink. Each
            ComEventSink implements a single source interface that COM object 
            supports. 
            3. ComEventSink contains a map between method DISPIDs to  the 
            multicast delegate that will be invoked when the event is raised.
            4. ComEventSink implements IReflect interface which is exposed as
            custom IDispatch to COM consumers. This allows us to intercept calls
            to IDispatch.Invoke and apply custom logic - in particular we will
            just find and invoke the multicast delegate corresponding to the invoked
            dispid.
             </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComDispatch.GenericComObject">
            <summary>
            We have no additional information about this COM object.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComDispatch.ComObject">
            <summary>
            This is a helper class for runtime-callable-wrappers of COM instances. We create one instance of this type
            for every generic RCW instance.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.ComObject.ObjectToComObject(System.Object)">
            <summary>
            This is the factory method to get the ComObject corresponding to an RCW
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.ComObject.GetTargetForGetMember(Microsoft.Scripting.Actions.RuleBuilder,Microsoft.Scripting.Actions.ActionBinder,Microsoft.Scripting.Actions.MemberAction)">
            <summary>
            Gets the target rule body for the GetMember action. This handles statements of the kind:
            comObject.Method(parameter1, parameter2, ...,  parameterN)
            comObject.Property
            The return value of the resulting AST is the result of the Method lookup or Property invocation as:
            comObject.LookUp("Method")
            comObject.Invoke("get_Property")
            In the case of comObject.Method, by returning a DispMethod instance, it is assumed that a subsequent call will be performed
            to resolve the method invocation.  The DispMethod instance is a callable object in keeping with the potential treatment
            of functions as first class objects.
            </summary>
            <param name="rule">The rule that the binder helper is attempting to construct, supplying temporary variables and parameters to the AST block.</param>
            <param name="binder">The binder that is provided by the language for conversions.</param>
            <param name="action">The get member that is to be performed.</param>
            <returns>
            This function returns an AST statement that implements the relevant method/property lookup/invoke.
            </returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.ComObject.GetTargetForSetMember(Microsoft.Scripting.Actions.RuleBuilder,Microsoft.Scripting.Actions.ActionBinder,Microsoft.Scripting.Actions.MemberAction)">
            <summary>
            Gets the target rule body for the SetMember action. This handles statements of the kind:
            
            comObject.Property = value
            
            The return value of the resulting AST is the result of the Property invocation as:
            
            comObject.Invoke("put_Property", value)
            </summary>
            <param name="rule">The rule that the binder helper is attempting to construct, supplying temporary variables and parameters to the AST block.</param>
            <param name="binder">The binder that is provided by the language for conversions.</param>
            <param name="action">The set member that is to be performed.</param>
            <returns>This function returns an AST statement that implements the required property set invocation.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.ComObject.GetTargetForDoOperation(Microsoft.Scripting.Actions.RuleBuilder,Microsoft.Scripting.Actions.ActionBinder,Microsoft.Scripting.Actions.DoOperationAction)">
            <summary>
            Gets the target rule body for the GetItem operation. This handles statements of the kind:
            
            comObject[index1, index2, ..., indexN]
            
            The return value of the resulting AST is the result of the IndexerMethod or IndexerProperty invocation as:
            
            comObject.Invoke("__propertyget__", index1, index2, ..., indexN)
            
            This implies that comObject implements a "default" method or property (DispId = 0) adorned with the PropertyPut attribute
            and most usually associated with the method/property name "Item".
            </summary>
            <param name="rule">The rule that the binder helper is attempting to construct, supplying temporary variables and parameters to the AST block.</param>
            <param name="binder">The binder that is provided by the language for conversions.</param>
            <param name="action">The do operation that is to be performed.</param>
            <returns>This function returns an AST statement that implements the indexed operation "propertyget".</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComBinderHelper`2.AddToBody(Microsoft.Scripting.Ast.Expression)">
            <summary>
            Use this method to extend the Body.  It will create BlockStatements as needed.
            </summary>
            <param name="expression"></param>
        </member>
        <member name="P:Microsoft.Scripting.Actions.ComBinderHelper`2.Body">
            <summary>
            There is no setter on Body.  Use AddToBody to extend it instead.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.ComMemberBinderHelper`2.StringName">
            <summary> helper to grab the name of the member we're looking up as a string </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.IDispatchComObject.GetMemberBinder`1.GetFailureStatement(System.Type,System.String)">
            <summary>
            Generate the failure Statement
                if Action.IsNoThrow = True
                    OperationFailed.Value 
                else
                    MakeMissingMemberError -> returns Undefined.Value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.IDispatchComObject.DoOperationBinder`1.GetFailureStatement(System.Type,System.String)">
            <summary>
            Generate the failure Statement
                if Action.IsNoThrow = True
                    OperationFailed.Value 
                else
                    MakeMissingMemberError -> returns Undefined.Value
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComDispatch.ComEventSinkProxy">
            <summary>
            ComEventSinkProxy class is responsible for handling QIs for sourceIid 
            on instances of ComEventSink.
            
            Background: When a COM even sink advises to a connection point it is 
            supposed to hand over the dispinterface. Now, some hosts will trust
            the COM client to pass the correct pointer, but some will not.
            E.g. Excel's implementation of Connection Points will not cause a
            QI on the pointer that has been passed, however Word will QI the
            pointer to return the required interface.
            
            ComEventSink does not, strongly speaking, implements the interface 
            that it claims to implement - it is just "faking" it by using IReflect.
            Thus, Word's QIs on the pointer passed to ICP::Advise would fail. To
            prevent this we take advangate of RealProxy's ability of
            "dressing up" like other classes and hence successfully respond to QIs 
            for interfaces that it does not really support( it is OK to say 
            "I implement this interface" for event sinks only since the common 
            practice is to use IDistpach.Invoke when calling into event sinks). 
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComDispatch.ComEventSink">
            <summary>
            This class implements an event sink for a particular RCW.
            Unlike the implementation of events in TlbImp'd assemblies,
            we will create only one event sink per RCW (theoretically RCW might have
            several ComEventSink evenk sinks - but all these implement different source intefaces).
            Each ComEventSink contains a list of ComEventSinkMethod objects - which represent
            a single method on the source interface an a multicast delegate to redirect 
            the calls. Notice that we are chaining multicast delegates so that same 
            ComEventSinkMedhod can invoke multiple event handlers).
            
            ComEventSink implements an IDisposable pattern to Unadvise from the connection point.
            Typically, when RCW is finalized the corresponding Dispose will be triggered by 
            ComEventSinksContainer finalizer. Notice that lifetime of ComEventSinksContainer
            is bound to the lifetime of the RCW. 
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComDispatch.ComEventSink.ComEventSinkMethod">
            <summary>
            Contains a methods DISPID (in a string formatted of "[DISPID=N]"
            and a chained list of delegates to invoke
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.Operators">
            <summary>
            Enum representing different types of operators.
            
            Operators can be Unary, Binary, or Ternary.  An individual operator can have one or 
            more arity.  
            
            Each operator is associated with a standard name.  If a method is named using the standard
            name and is marked with OperatorMethodAttribute then the method will automatically be
            detected as an operator.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Call">
            <summary>
            Binary operator.
            
            Attempt to call the object.  Arguments are the object and the arguments for the call.  The
            arguments for the call can either be an object array (normal call) or a KwCallInfo class for
            performing a keyword based call.
            
            The standard name for this operator is "Call".
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.CodeRepresentation">
            <summary>
            Unary operator.
            
            Returns a string which defines the object in code or a language specific format for
            objects which cannot be represented in code.  This operator generally is not used in
            a non-language specific scenario.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.MemberNames">
            <summary>
            Unary operator.
            
            Gets the list of members that belong to the current object returned as an IList of string
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Documentation">
            <summary>
            Unary operator.
            
            Gets various documentation about the object returned as a string
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.CallSignatures">
            <summary>
            Unary operator.
            
            Gets information about the type of parameters, returned as a string.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.IsCallable">
            <summary>
            Unary operator.
            
            Checks whether the object is callable or not, returns true if it is.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Add">
            <summary>Operator for performing add</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Subtract">
            <summary>Operator for performing sub</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Power">
            <summary>Operator for performing pow</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Multiply">
            <summary>Operator for performing mul</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.FloorDivide">
            <summary>Operator for performing floordiv</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Divide">
            <summary>Operator for performing div</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.TrueDivide">
            <summary>Operator for performing truediv</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Mod">
            <summary>Operator for performing mod</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.LeftShift">
            <summary>Operator for performing lshift</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.RightShift">
            <summary>Operator for performing rshift</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.BitwiseAnd">
            <summary>Operator for performing and</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.BitwiseOr">
            <summary>Operator for performing or</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ExclusiveOr">
            <summary>Operator for performing xor</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.LessThan">
            <summary>Operator for performing lt</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.GreaterThan">
            <summary>Operator for performing gt</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.LessThanOrEqual">
            <summary>Operator for performing le</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.GreaterThanOrEqual">
            <summary>Operator for performing ge</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Equals">
            <summary>Operator for performing eq</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.NotEquals">
            <summary>Operator for performing ne</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.LessThanGreaterThan">
            <summary>Operator for performing lg</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceAdd">
            <summary>Operator for performing in-place add</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceSubtract">
            <summary>Operator for performing in-place sub</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlacePower">
            <summary>Operator for performing in-place pow</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceMultiply">
            <summary>Operator for performing in-place mul</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceFloorDivide">
            <summary>Operator for performing in-place floordiv</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceDivide">
            <summary>Operator for performing in-place div</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceTrueDivide">
            <summary>Operator for performing in-place truediv</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceMod">
            <summary>Operator for performing in-place mod</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceLeftShift">
            <summary>Operator for performing in-place lshift</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceRightShift">
            <summary>Operator for performing in-place rshift</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceBitwiseAnd">
            <summary>Operator for performing in-place and</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceBitwiseOr">
            <summary>Operator for performing in-place or</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceExclusiveOr">
            <summary>Operator for performing in-place xor</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseAdd">
            <summary>Operator for performing reverse add</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseSubtract">
            <summary>Operator for performing reverse sub</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReversePower">
            <summary>Operator for performing reverse pow</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseMultiply">
            <summary>Operator for performing reverse mul</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseFloorDivide">
            <summary>Operator for performing reverse floordiv</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseDivide">
            <summary>Operator for performing reverse div</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseTrueDivide">
            <summary>Operator for performing reverse truediv</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseMod">
            <summary>Operator for performing reverse mod</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseLeftShift">
            <summary>Operator for performing reverse lshift</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseRightShift">
            <summary>Operator for performing reverse rshift</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseBitwiseAnd">
            <summary>Operator for performing reverse and</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseBitwiseOr">
            <summary>Operator for performing reverse or</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseExclusiveOr">
            <summary>Operator for performing reverse xor</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Contains">
            <summary>
            Binary operator.
            
            Checks to see if the instance contains another object.  Returns true or false.
            
            The standard name for this operator is "Contains".
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.GetItem">
            <summary>
            n-ary operator.
            
            Gets the value at the specified index from the instance.
            
            One or more indexes can be provided as individual arguments.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.SetItem">
            <summary>
            n-ary operator.
            
            Sets the value at the specified index in the instance.
            
            One or more indexes can be provided as individual arguments.  The last value provided is the value to be set.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.DeleteItem">
            <summary>
            n-ary operator.
            
            Removes the item from the specified index in the instance.
            
            One or more indexes can be provided as individual arguments.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.GetSlice">
            <summary>
            Binary or Ternary operator.
            
            Gets the specified range of elements (slice) from the instance.
            
            The slice parameters may include the start index, the end index, and the step value.  The step value is optional.
            
            A value of Type.Missing may be provided if no parameter was explicitly provided for a start, stop or step parameter.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.SetSlice">
            <summary>
            n-ary operator.
            
            Sets the specified range of elements in the instance.
            
            The slice parameters may include the start index, the end index, and the step value.  The step
            value is optional.  The last parameter is the value to be assigned.
            
            A value of Type.Missing may be provided if no parameter was explicitly provided for a start, stop or step parameter.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.DeleteSlice">
            <summary>
            n-ary operator.
            
            Removes the specified range of elements from the instance.
            
            The slice parameters may include the start index, the end index, and the step value.  The step value is
            optional.
            
            A value of Type.Missing may be provided if no parameter was explicitly provided for a start, stop or step parameter.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Length">
            <summary>
            Unary operator.
            
            Returns the number of items stored in the object.
            </summary>      
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Compare">
            <summary>
            Binary operator.
            
            Compares two instances returning an integer indicating the relationship between them.  May
            throw if the object types are uncomparable.
            
            The standard name for this operator is "Compare".
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.DivMod">
            <summary>
            Binary operator.
            
            Returns both the dividend and quotioent of x / y.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseDivMod">
            <summary>
            Binary operator.
            
            Returns both the dividend and quotient of y / x.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.GetMember">
            <summary>
            Member lookup customization (called after type lookup).
            
            Arguments are the instance to get the member from and a SymbolId which represents the member.
            
            The return value is the member.
            
            The standard name for this operator is "GetMember".
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.GetBoundMember">
            <summary>
            Member lookup customization for bound attributes
            
            Arguments are the instance to get the member from and a SymbolId which represents the bound member.
            
            The return value is the bound member.
            
            /// The standard name for this operator is "GetBoundMember".
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.SetMember">
            <summary>
            Member set customization.
            
            Arguments are the instance, the SymbolId to get, and the new value for the member.
            
            The return value is ignored.
            
            The standard name for this operator is "SetMember".
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.DeleteMember">
            <summary>
            Member delete customization.
            
            Arguments are the instance and the SymbolId for the member to delete.
            
            The return value is ignored.
            
            The standard name for this operator is "DeleteMember".
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.GetMemberNames">
            <summary>
            Attribute customization operator.  Returns a list of names that should be displayed as
            being part of the object.
            
            Arguments are the instance to get the list of member names from.
            
            Return value is IList&lt;SymbolId&gt;.
            
            /// The standard name for this operator is "GetMemberNames".
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.AbsoluteValue">
            <summary>
            Unary operator.
            
            Get the absolute value of the instance.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Positive">
            <summary>
            Unary operator.
            
            Gets the positive value of the instance.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Negate">
            <summary>
            Unary operator.
            
            Negates the instance and return the new value.
            </summary>        
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.OnesComplement">
            <summary>
            Unary operator.
            
            Returns the ones complement of the instance.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update1``3(Microsoft.Scripting.Actions.CallSite,``1)">
            <summary>
            Site update code - arity 1
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update2``4(Microsoft.Scripting.Actions.CallSite,``1,``2)">
            <summary>
            Site update code - arity 2
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update3``5(Microsoft.Scripting.Actions.CallSite,``1,``2,``3)">
            <summary>
            Site update code - arity 3
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update4``6(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4)">
            <summary>
            Site update code - arity 4
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update5``7(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5)">
            <summary>
            Site update code - arity 5
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update6``8(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6)">
            <summary>
            Site update code - arity 6
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update7``9(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6,``7)">
            <summary>
            Site update code - arity 7
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update8``10(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>
            Site update code - arity 8
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update9``11(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
            <summary>
            Site update code - arity 9
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.Scope">
            <summary>
            Represents a context of execution.  A context of execution has a set of variables
            associated with it (its dictionary) and a parent context.  
            
            When looking up a name from a context first the local context is searched.  If the
            name is not found there the name lookup will be done against the parent context.
            
            Scopes can have language-sensitive variables that are only exposed to a single
            language based upon its calling context.  When searching the
            language-sensitive dictionary is searched first.  If no matches are found the lookup
            is delegated back to the LanguageContext.  If the LanguageContext fails to lookup
            the name it delegates back to the (Host or ScriptRuntime?)
            
            Each member of the Scope can optionally have a certain set of attributes associated
            with it (ScopeMemberAttributes).  These permit members of the scope to be read-only,
            non-deletable, or hidden from enumeration.
            
            Scopes, like IAttrbibuteCollections, support both being indexed by SymbolId for fast
            access as well as being indexed by object.  The preferred access is via SymbolId and
            object access is provided for languages which require additional semantics.  All
            features supported for feature IDs are also supported for objects (e.g. context-sentsitivity
            and attributes) but the object API does not contain all the same sets of overloads provided
            for convenience.
            
            TODO: Thread safety
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.#ctor">
            <summary>
            Creates a new top-level scope with a new empty dictionary.  The scope
            is marked as being visible.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.#ctor(Microsoft.Scripting.IAttributesCollection)">
            <summary>
            Creates a new top-level Scope with the provided dictionary
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.#ctor(Microsoft.Scripting.Runtime.Scope,Microsoft.Scripting.IAttributesCollection)">
            <summary>
            Creates a new Scope with the provided parent and dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.#ctor(Microsoft.Scripting.Runtime.Scope,Microsoft.Scripting.IAttributesCollection,System.Boolean)">
            <summary>
            Creates a new Scope with the provided parent, dictionary and visibility.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.GetKeys(Microsoft.Scripting.Runtime.LanguageContext)">
            <summary>
            Returns the list of Keys available to all languages in addition to those keys
            which are only available to the provided LanguageContext.
            
            Keys marked with the DontEnumerate flag will not be returned.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.TryGetName(Microsoft.Scripting.SymbolId,System.Object@)">
            <summary>
            Trys to lookup the provided name in the current scope.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.TryGetName(Microsoft.Scripting.Runtime.LanguageContext,Microsoft.Scripting.SymbolId,System.Object@)">
            <summary>
            Trys to lookup the provided name in the current scope.  Search includes
            names that are only visible to the provided LanguageContext.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.TryGetNameForContext(Microsoft.Scripting.Runtime.LanguageContext,Microsoft.Scripting.SymbolId,System.Object@)">
            <summary>
            Trys to lookup the provided name in the current scope's context specific dictionary.  
            Search includes names that are only visible to the provided LanguageContext.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.TryLookupName(Microsoft.Scripting.SymbolId,System.Object@)">
            <summary>
            Attempts to lookup the provided name in this scope or any outer scope.   
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.TryLookupName(Microsoft.Scripting.Runtime.LanguageContext,Microsoft.Scripting.SymbolId,System.Object@)">
            <summary>
            Attempts to lookup the provided name in this scope or any outer scope.   Lookup
            includes searching for names that are only visible to the provided LanguageContext.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.LookupName(Microsoft.Scripting.SymbolId)">
            <summary>
            Attempts to lookup the provided name in this scope or any outer scope.   If the
            name is not defined MissingMemberException is thrown.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.LookupName(Microsoft.Scripting.Runtime.LanguageContext,Microsoft.Scripting.SymbolId)">
            <summary>
            Attempts to lookup the provided name in this scope or any outer scope.  The
            search includes looking for names that are only visible to the provided LanguageContext.
            
            If the name is not defined the language defined MissingName exception is thrown.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.SetName(Microsoft.Scripting.SymbolId,System.Object)">
            <summary>
            Sets the name to the specified value for the current context.
            </summary>
            <exception cref="T:System.MemberAccessException">The name has already been published and marked as ReadOnly</exception>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.SetName(Microsoft.Scripting.SymbolId,System.Object,Microsoft.Scripting.Runtime.ScopeMemberAttributes)">
            <summary>
            Sets the name to the specified value for the current context.
            
            Provides the ScopeMemberAttributes which should be set on the provided object.
            </summary>
            <exception cref="T:System.MemberAccessException">The name has already been published and marked as ReadOnly</exception>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.SetName(Microsoft.Scripting.Runtime.ContextId,Microsoft.Scripting.SymbolId,System.Object,Microsoft.Scripting.Runtime.ScopeMemberAttributes)">
            <summary>
            Sets a name that is only available in the specified context.
            
            Provides the ScopeMemberAttributes which should be set on the provided object.
            </summary>
            <exception cref="T:System.MemberAccessException">The name has already been published and marked as ReadOnly</exception>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.Clear">
            <summary>
            Removes all members from the dictionary and any context-sensitive dictionaries.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.ContainsName(Microsoft.Scripting.SymbolId)">
            <summary>
            Determines if this context or any outer scope contains the defined name.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.ContainsName(Microsoft.Scripting.Runtime.LanguageContext,Microsoft.Scripting.SymbolId)">
            <summary>
            Determines if this context or any outer scope contains the defined name that
            is available from the provided LanguageContext.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.RemoveName(Microsoft.Scripting.SymbolId)">
            <summary>
            Removes the provided name from this scope
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.RemoveName(Microsoft.Scripting.Runtime.LanguageContext,Microsoft.Scripting.SymbolId)">
            <summary>
            Removes the provided name from this scope removing names
            visible to both the current context and all contexts.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.RemoveNameForContext(Microsoft.Scripting.Runtime.LanguageContext,Microsoft.Scripting.SymbolId)">
            <summary>
            Removes the provided name from this scope removing names
            visible to both the current context and all contexts.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.TryRemoveName(Microsoft.Scripting.SymbolId)">
            <summary>
            Attemps to remove the provided name from this scope
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.TryRemoveName(Microsoft.Scripting.Runtime.LanguageContext,Microsoft.Scripting.SymbolId)">
            <summary>
            Attemps to remove the provided name from this scope removing names visible
            to both the current context and all contexts.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.TryRemoveForContext(Microsoft.Scripting.Runtime.LanguageContext,Microsoft.Scripting.SymbolId)">
            <summary>
            Attemps to remove the provided name from this scope's context specific dictionary
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.TryRemoveObjectName(Microsoft.Scripting.Runtime.LanguageContext,System.Object)">
            <summary>
            Attemps to remove the provided object name from this scope removing names visible
            to both the current context and all contexts.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.TryGetObjectName(Microsoft.Scripting.Runtime.LanguageContext,System.Object,System.Object@)">
            <summary>
            Trys to lookup the provided name in the current scope.  Search includes
            names that are only visible to the provided LanguageContext.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.TryLookupObjectName(Microsoft.Scripting.Runtime.LanguageContext,System.Object,System.Object@)">
            <summary>
            Attempts to lookup the provided object name in this scope or any outer scope.   Lookup
            includes searching for names that are visible to the provided LanguageContext as well
            as those available to all contexts.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.SetObjectName(System.Object,System.Object)">
            <summary>
            Sets the name to the specified value for the current context.
            
            The name is an arbitrary object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.SetObjectName(Microsoft.Scripting.Runtime.ContextId,System.Object,System.Object,Microsoft.Scripting.Runtime.ScopeMemberAttributes)">
            <summary>
            Sets the name to the specified value for the current context.
            
            The name is an arbitrary object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.GetAllKeys(Microsoft.Scripting.Runtime.LanguageContext)">
            <summary>
            Returns the list of Keys available to all languages in addition to those keys
            which are only available to the provided LanguageContext.
            
            Keys marked with the DontEnumerate flag will not be returned.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.GetAllItems(Microsoft.Scripting.Runtime.LanguageContext)">
            <summary>
            Returns the list of Keys and Values available to all languages in addition to those
            keys which are only available to the provided LanguageContext.
            
            Keys marked with DontEnumerate flag will not be returned.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.Scope.Parent">
            <summary>
            Gets the parent of this Scope or null if the Scope has no parent.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.Scope.IsVisible">
            <summary>
            Gets if the context is visible at this scope.  Visibility is a per-language feature that enables
            languages to include members in the Scope chain but hide them when directly exposed to the user.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.Scope.Keys">
            <summary>
            Returns the list of keys which are available to all languages.  Keys marked with the
            DontEnumerate flag will not be returned.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.Scope.Items">
            <summary>
            Returns the list of Keys and Items which are available to all langauges.  Keys marked
            with the DontEnumerate flag will not be returned.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.Scope.ModuleScope">
            <summary>
            Gets the outer-most scope associated with this scope.  
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.Scope.Dict">
            <summary>
            Default scope dictionary
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.Scope.ContextSensitiveScope">
            <summary>
            Helper class to hold onto all the context-sensitive information for a Scope.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.Scope.ScopeAttributeDictionary">
            <summary>
            Helper class to hold the attributes for both SymbolId and object attributes.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceCodeProperties.IsInvalid">
            <summary>
            Source code is already invalid and no suffix can make it syntactically correct.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceCodeProperties.IsIncompleteToken">
            <summary>
            Last token is incomplete. Source code can still be completed correctly.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceCodeProperties.IsIncompleteStatement">
            <summary>
            Last statement is incomplete. Source code can still be completed correctly.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceCodeProperties.IsEmpty">
            <summary>
            String represents an empty statement/expression.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.DoStatement.#ctor(Microsoft.Scripting.Ast.Annotations,Microsoft.Scripting.Ast.LabelTarget,Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.Expression)">
            <summary>
            Called by <see cref="T:Microsoft.Scripting.Ast.DoStatementBuilder"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.GlobalLookupRewriter">
            <summary>
            Converts globals to late bound lookups on the scope
            TODO: move to Microsoft.Scripting
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.RuntimeHelpers">
            <summary>
            These are some generally useful helper methods. Currently the only methods are those to
            cached boxed representations of commonly used primitive types so that they can be shared.
            This is useful to most dynamic languages that use object as a universal type.
            
            The methods in RuntimeHelepers are caleld by the generated code. From here the methods may
            dispatch to other parts of the runtime to get bulk of the work done, but the entry points
            should be here.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.RuntimeHelpers.LookupGlobalName(Microsoft.Scripting.Runtime.CodeContext,Microsoft.Scripting.SymbolId)">
            <summary>
            Called from generated code, helper to do a global name lookup
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.RuntimeHelpers.SetGlobalName(Microsoft.Scripting.Runtime.CodeContext,Microsoft.Scripting.SymbolId,System.Object)">
            <summary>
            Called from generated code, helper to do global name assignment
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.RuntimeHelpers.LookupName(Microsoft.Scripting.Runtime.CodeContext,Microsoft.Scripting.SymbolId)">
            <summary>
            Called from generated code, helper to do name lookup
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.RuntimeHelpers.SetName(Microsoft.Scripting.Runtime.CodeContext,Microsoft.Scripting.SymbolId,System.Object)">
            <summary>
            Called from generated code, helper to do name assignment
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.RuntimeHelpers.True">
            <summary> Singleton boxed instance of True.  We should never box additional instances. </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.RuntimeHelpers.False">
            <summary> Singleton boxed instance of False  We should never box additional instances. </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.RuntimeHelpers.CreateInstance``1">
            <summary>
            Helper method to create an instance.  Work around for Silverlight where Activator.CreateInstance
            is SecuritySafeCritical.
            
            TODO: Why can't we just emit the right thing for default(T)?
            It's always null for reference types and it's well defined for value types
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.RuntimeHelpers.GetEventHandlerType(System.Reflection.EventInfo)">
            <summary>
            EventInfo.EventHandlerType getter is marked SecuritySafeCritical in CoreCLR
            This method is to get to the property without using Reflection
            </summary>
            <param name="eventInfo"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.RuntimeHelpers.ShiftParamsArray``1(``0[],System.Int32)">
            <summary>
            Used by the code gen of wrapper methods which extract subset of the params array
            manually, but then extract the rest in bulk if the underlying method also takes
            params array.
            
            This calls ArrayUtils.ShiftLeft, but performs additional checks that
            ArrayUtils.ShiftLeft assumes.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Stitcher">
            <summary>
            Stitcher, a.k.a Rule inliner. Takes list of rules and produces LambdaExpression with the
            rules inlined, adding the "update" call at the very end.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Stitcher._lp">
            <summary>
            LambdaExpression parameters
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Stitcher._map">
            <summary>
            Mapping of the ParameterExpression (rule) -> ParameterExpression (lambda)
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.Closure">
            <summary>
            If the delegate generated by the Lambda compiler needs to either be a closure, or close
            over constant pool, the delegate itself will close over the instance of this object.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.Closure.Constants">
            <summary>
            The constant pool
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.Closure.Environment">
            <summary>
            The environment, which stores closed over variables from the parent
            scope
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.TopNamespaceTracker">
            <summary>
            Represents the top reflected package which contains extra information such as
            all the assemblies loaded and the built-in modules.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.NamespaceTracker">
            <summary>
            NamespaceTracker represent a CLS namespace.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.NamespaceTracker.LoadAllTypes">
            <summary>
            Loads all the types from all assemblies that contribute to the current namespace (but not child namespaces)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.NamespaceTracker.GetOrMakePackageHierarchy(System.Reflection.Assembly,System.String)">
            <summary>
            Populates the tree with nodes for each part of the namespace
            </summary>
            <param name="assem"></param>
            <param name="fullNamespace">Full namespace name. It can be null (for top-level types)</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.NamespaceTracker.CheckForUnlistedType(System.String)">
            <summary>
            As a fallback, so if the type does exist in any assembly. This would happen if a new type was added
            that was not in the hardcoded list of types. 
            This code is not accurate because:
            1. We dont deal with generic types (TypeCollision). 
            2. Previous calls to GetCustomMemberNames (eg. "from foo import *" in Python) would not have included this type.
            3. This does not deal with new namespaces added to the assembly
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.NamespaceTracker.TypeNames">
            <summary>
            This stores all the public non-nested type names in a single namespace and from a single assembly.
            This allows inspection of the namespace without eagerly loading all the types. Eagerly loading
            types slows down startup, increases working set, and is semantically incorrect as it can trigger
            TypeLoadExceptions sooner than required.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TopNamespaceTracker.TryGetPackage(System.String)">
            <summary>
            returns the package associated with the specified namespace and
            updates the associated module to mark the package as imported.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TopNamespaceTracker.LoadAssembly(System.Reflection.Assembly)">
            <summary>
            Ensures that the assembly is loaded
            </summary>
            <param name="assem"></param>
            <returns>true if the assembly was loaded for the first time. 
            false if the assembly had already been loaded before</returns>
        </member>
        <member name="F:Microsoft.Scripting.Actions.GetMemberBindingFlags.None">
            <summary>
            No member binding flags
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.GetMemberBindingFlags.Bound">
            <summary>
            The result of the get should produce a value that is bound to the instance it was extracted from, if possible.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.GetMemberBindingFlags.NoThrow">
            <summary>
            Instead of throwing the binder will return OperationFailed.Value if the member does not exist or is write-only.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.MethodGroup">
            <summary>
            MethodGroup's represent a unique collection of method's.  Typically this
            unique set is all the methods which are overloaded by the same name including
            methods with different arity.  These methods represent a single logically
            overloaded element of a .NET type.
            
            The base DLR binders will produce MethodGroup's when provided with a MemberGroup
            which contains only methods.  The MethodGroup's will be unique instances per
            each unique group of methods.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MethodGroup.MakeGenericMethod(System.Type[])">
            <summary>
            Returns a BuiltinFunction bound to the provided type arguments.  Returns null if the binding
            cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ReturnBuilder.#ctor(System.Type)">
            <summary>
            Creates a ReturnBuilder
            </summary>
            <param name="returnType">the type the ReturnBuilder will leave on the stack</param>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ReturnBuilder.Build(Microsoft.Scripting.Runtime.CodeContext,System.Object[],System.Object[],System.Object)">
            <summary>
            
            </summary>
            <param name="context"></param>
            <param name="args">The physical arguments being passed to the function</param>
            <param name="parameters">The arguments the user provided to call the function</param>
            <param name="ret">The return value of the function</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComDispatch.ExcepInfo">
            <summary>
            This is similar to ComTypes.EXCEPINFO, but lets us do our own custom marshaling
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComDispatch.DispCallable">
            <summary>
            This represents a bound dispmethod on a IDispatch object.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComDispatch.DispCallable.CallBinder`1">
            <summary>
            Creates a rule for calling a COM method using IDispatch::Invoke
            </summary>
            <typeparam name="T">Type of the DynamicSite</typeparam>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComCallBinderHelper`2">
            <summary>
            Creates rules for performing method calls.  Currently supports calling built-in functions, built-in method descriptors (w/o 
            a bound value) and bound built-in method descriptors (w/ a bound value), delegates, types defining a "Call" method marked
            with SpecialName.
            </summary>
            <typeparam name="T">The type of the dynamic site</typeparam>
            <typeparam name="TAction">The specific type of CallAction</typeparam>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComCallBinderHelper`2.MakeArgumentExpressions">
            <summary>
            Gets expressions to access all the arguments. This includes the instance argument. Splat arguments are
            unpacked in the output. The resulting array is similar to Rule.Parameters (but also different in some ways)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComCallBinderHelper`2.MakeSplatTests">
            <summary>
            Makes test for param arrays and param dictionary parameters.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComCallBinderHelper`2.GetArgumentNamesAndTypes(Microsoft.Scripting.SymbolId[]@,System.Type[]@)">
            <summary>
            Gets all of the argument names and types. The instance argument is not included
            </summary>
            <param name="argNames">The names correspond to the end of argTypes.
            ArgumentKind.Dictionary is unpacked in the return value.
            This is set to an array of size 0 if there are no keyword arguments</param>
            <param name="argTypes">Non named arguments are returned at the beginning.
            ArgumentKind.List is unpacked in the return value. </param>
        </member>
        <member name="P:Microsoft.Scripting.Actions.ComCallBinderHelper`2.Instance">
            <summary>
            The instance for the target method, or null if this is a non-instance call.
            
            If it is set, it will typically be set to extract the instance from the Callable.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.DispCallable.CallBinder`1.MakeIDispatchInvokeTarget">
            <summary>
            Create a stub for the target of the optimized lopop.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.CreateInstance``1(System.Type,System.Object[])">
            <exception cref="T:Microsoft.Scripting.Runtime.InvalidImplementationException">The type failed to instantiate.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.CreateDelegate(System.Reflection.MethodInfo,System.Type)">
            <summary>
            Creates an open delegate for the given (dynamic)method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.CreateDelegate(System.Reflection.MethodInfo,System.Type,System.Object)">
            <summary>
            Creates a closed delegate for the given (dynamic)method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.GetDeclaredInterfaces(System.Type)">
            <summary>
            Like Type.GetInterfaces, but only returns the interfaces implemented by this type
            and not its parents.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.TransformDictionaryEnumerator">
            <summary>
            Exposes a IDictionary&lt;SymbolId, object&gt; as a IDictionary&lt;object, object&lt;
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ScopeMemberAttributes">
            <summary>
            Common attributes used to control attributes of a Scope.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ScopeMemberAttributes.None">
            <summary>
            The member has no Scope attributes.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ScopeMemberAttributes.ReadOnly">
            <summary>
            The member can only be read from and cannot be written to
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ScopeMemberAttributes.DontDelete">
            <summary>
            The member can be read from or written to but cannot be deleted
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ScopeMemberAttributes.DontEnumerate">
            <summary>
            The member can be read or written but is not visible in the displayed list of members.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.FileStreamContentProvider">
            <summary>
            Provides a StreamContentProvider for a stream of content backed by a file on disk.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.EngineOptions.InterpretedMode">
            <summary>
            Interpret code instead of emitting it.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.EngineOptions.ExceptionDetail">
            <summary>
             Display exception detail (callstack) when exception gets caught
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.EngineOptions.PerfStats">
            <summary>
            Whther to gather performance statistics.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ConversionResultKind">
            <summary>
            Determines the result of a conversion action.  The result can either result in an exception, a value that
            has been successfully converted or default(T), or a true/false result indicating if the value can be converted.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ConversionResultKind.ImplicitCast">
            <summary>
            Attempts to perform available implicit conversions and throws if there are no available conversions.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ConversionResultKind.ExplicitCast">
            <summary>
            Attempst to perform available implicit and explicit conversions and throws if there are no available conversions.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ConversionResultKind.ImplicitTry">
            <summary>
            Attempts to perform available implicit conversions and returns default(ReturnType) if no conversions can be performed.
            
            If the return type of the rule is a value type then the return value will be zero-initialized.  If the return type
            of the rule is object or another class then the return type will be null (even if the conversion is to a value type).
            This enables ImplicitTry to be used to do TryConvertTo even if the type is value type (and the difference between
            null and a real value can be distinguished).
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ConversionResultKind.ExplicitTry">
            <summary>
            Attempts to perform available implicit and explicit conversions and returns default(ReturnType) if no conversions 
            can be performed.
            
            If the return type of the rule is a value type then the return value will be zero-initialized.  If the return type
            of the rule is object or another class then the return type will be null (even if the conversion is to a value type).
            This enables ExplicitTry to be used to do TryConvertTo even if the type is value type (and the difference between
            null and a real value can be distinguished).
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComDispatch.IDispatchObject">
            <summary>
            The object used to cache information about an IDispatch RCW object. This will be associated with
            every IDispatch RCW that is handled by the DLR.
            
            
            TODO: This should inherit from ComObject once ComObject is moved to the DLR
            
            
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.IDispatchObject.GetDispatchPointerInCurrentApartment">
            <summary>
            The caller should also call ReleaseDispatchPointer.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComDispatch.ComEventSinksContainer">
            <summary>
            ComEventSinksContainer is just a regular list with a finalizer.
            This list is usually attached as a custom data for RCW object and 
            is finalized whenever RCW is finalized.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.ArgBuilder">
            <summary>
            ArgBuilder provides an argument value used by the MethodBinder.  One ArgBuilder exists for each
            physical parameter defined on a method.  
            
            Contrast this with ParameterWrapper which represents the logical argument passed to the method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ArgBuilder.ToExpression(Microsoft.Scripting.Generation.MethodBinderContext,System.Collections.Generic.IList{Microsoft.Scripting.Ast.Expression})">
            <summary>
            Provides the Expression which provides the value to be passed to the argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ArgBuilder.UpdateFromReturn(System.Collections.Generic.IList{Microsoft.Scripting.Ast.Expression})">
            <summary>
            Provides an Expression which will update the provided value after a call to the method.  May
            return null if no update is required.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ArgBuilder.Build(Microsoft.Scripting.Runtime.CodeContext,System.Object[])">
            <summary>
            Builds the value of the argument to be passed for a call via reflection.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ArgBuilder.UpdateFromReturn(System.Object,System.Object[])">
            <summary>
            If the argument produces a return value (e.g. a ref or out value) this
            provides the additional value to be returned.
            This will not be called if the method call throws an exception, and so it should not
            be used for cleanup that is required to be done.
            </summary>
            <param name="callArg">The (potentially updated) value of the byref argument</param>
            <param name="args">The original argument list. One element of the list may get updated if it is
            being passed as a byref parameter that needs to follow copy-in copy-out semantics</param>
        </member>
        <member name="P:Microsoft.Scripting.Generation.ArgBuilder.Type">
            <summary>
            Returns the type required for the argument or null if the ArgBuilder
            does not consume a type.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.CallSignature">
            <summary>
            Richly represents the signature of a callsite.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.CallSignature._infos">
            <summary>
            Array of additional meta information about the arguments, such as named arguments.
            Null for a simple signature that's just an expression list. eg: foo(a*b,c,d)
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.CallSignature._argumentCount">
            <summary>
            Number of arguments in the signature.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.CallSignature.HasKeywordArgument">
            <summary>
            True if the CallAction includes an ArgumentInfo of ArgumentKind.Dictionary or ArgumentKind.Named.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.CallSignature.GetProvidedPositionalArgumentCount">
            <summary>
            Gets the number of positional arguments the user provided at the call site.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.CallSignature.IsSimple">
            <summary>
            All arguments are unnamed and matched by position. 
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.EndOfStream">
            <summary>
            A token marking an end of stream.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.WhiteSpace">
            <summary>
            A space, tab, or newline.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.Comment">
            <summary>
            A block comment.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.LineComment">
            <summary>
            A single line comment.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.DocComment">
            <summary>
            A documentation comment.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.NumericLiteral">
            <summary>
            A numeric literal.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.CharacterLiteral">
            <summary>
            A character literal.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.StringLiteral">
            <summary>
            A string literal.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.RegularExpressionLiteral">
            <summary>
            A regular expression literal.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.Keyword">
            <summary>
            A keyword.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.Directive">
            <summary>
            A directive (e.g. #line).
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.Operator">
            <summary>
            A punctuation character that has a specific meaning in a language.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.Delimiter">
            <summary>
            A token that operates as a separator between two language elements.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.Identifier">
            <summary>
            An identifier (variable, $variable, @variable, @@variable, $variable$, function!, function?, [variable], i'variable', ...)
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.Grouping">
            <summary>
            Braces, parenthesis, brackets.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.Error">
            <summary>
            Errors.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.StaticExtensionMethodAttribute">
            <summary>
            Indicates an extension method should be added as a static method, not a instance method.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ModuleChangeType">
            <summary>
            The way in which a module has changed : Set or Delete
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ModuleChangeType.Set">
            <summary>
            A new value has been set in the module (or a previous value has changed).
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ModuleChangeType.Delete">
            <summary>
            A value has been removed from the module.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.PropertySlot">
            <summary>
            Slot that accesses a property off an object
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.ConversionResult">
            <summary>
            Represents information about a failure to convert an argument from one
            type to another.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.LocalScopeExpression">
            <summary>
            An expression that provides run-time read/write access to variables in
            the local scope. Needed to implement "eval" in dynamic languages.
            Evaluates to an instance of ILocalVariables at run time.
             
            TODO: this currently returns all in-scope variables in the lambda. We
            need to stop merging scopes in the compiler to fix this.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LocalScopeExpression.AllVariables">
            <summary>
            Returns true if access to all variables in scope will be provided,
            false if only lifted (closed over) variables will be present
            
            Providing all variables is sometimes necessary for language
            semantics, but carries with it a performance penalty because these
            variables can't be true IL locals.
            
            TODO: can we remove this flag without hurting performance?
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SourceUnit.GetCodeLines(System.Int32,System.Int32)">
            <summary>
            Reads specified range of lines (or less) from the source unit. 
            Line numbers starts with 1.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SourceUnit.GetSymbolDocument(System.Int32)">
            <summary>
            Returns null if unknown/undefined.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SourceUnit.Compile(Microsoft.Scripting.CompilerOptions,Microsoft.Scripting.ErrorSink)">
            <summary>
            Errors are reported to the specified sink. 
            Returns <c>null</c> if the parser cannot compile the code due to error(s).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SourceUnit.Execute">
            <summary>
            Executes in an optimized scope.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SourceUnit.Execute(Microsoft.Scripting.CompilerOptions,Microsoft.Scripting.ErrorSink)">
            <summary>
            Executes in an optimized scope.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceUnit.Path">
            <summary>
            Identification of the source unit. Assigned by the host. 
            The format and semantics is host dependent (could be a path on file system or URL).
            Empty string for anonymous source units.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceUnit.LanguageContext">
            <summary>
            LanguageContext of the language of the unit.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.LabelTarget">
            <summary>
            Used by BreakStatement and ContinueStatement to specify the target of
            the break/continue. The label object is shared with the enclosing
            LabeledStatement, LoopStatement, SwitchStatement, or DoStatement, 
            indicating which statement to break/continue out of
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LabelTarget.Name">
            <summary>
            The name of the label, possibly empty.
            The name is purely descriptive, so it doesn't have to be unique
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.ScopeInfo">
            <summary>
            ScopeInfo is the data structure which the Compiler keeps information
            related to compiling scopes. It stores the following information:
              1. Parent relationship (for resolving variables)
              2. Information about lifted variables
              3. Information for resolving closures
            
            Instances are produced by VariableBinder, which does a tree walk
            looking for scope nodes: LambdaExpression, GeneratorLambdaExpression,
            and ScopeExpression.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.ScopeInfo.Enter(Microsoft.Scripting.Ast.LambdaCompiler)">
            <summary>
            Called when entering the scope. Performs all variable allocation
            needed, including creating environments and IL locals for accessing
            parent environments
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.ScopeInfo.Exit">
            <summary>
            Called when exiting the scope. Clears out slots for IL locals.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.ScopeInfo.EmitNearestEnvironment(Microsoft.Scripting.Ast.LambdaCompiler)">
            <summary>
            Emit the nearest environment, or null is there isn't one
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.ScopeInfo.ResolveVariable(Microsoft.Scripting.Ast.Expression)">
            <summary>
            Resolve a local variable in this scope or a closed over scope
            Throws if the variable is defined
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.ScopeInfo.Expression">
            <summary>
            The lambda or scope expression associated with this scope
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.ScopeInfo.IsClosure">
            <summary>
            Indicates that this scope closes over variables in a parent scope
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.ScopeInfo.HasEnvironment">
            <summary>
            Indicates that this scope has lifted variables
            
            These are either closed over from a parent scope, or lifted so we
            can provide access via the Expression.LocalVariables() intrinsic.
            (TODO: the latter part is not implemented yet)
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.ScopeInfo.GeneratorOuterScope">
            <summary>
            If this scope represents an inner generator, this will return the outer
            generator scope. Otherwise, returns null
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.ScopeInfo.EnvironmentInfo">
            <summary>
            Represents an environment, which contains only lifted variables
            and is stored in an array. Independant of ScopeInfo because not all
            scopes have an environment.
            
            Invariant: this class stores no compiler state and is safe to emit
              under different LambdaCompilers
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Matchmaker">
            <summary>
            This class is used to look for matching rules in the caches
            by executing individual rules against the site whose fallback
            code delegates here.
            </summary>
            <summary>
            This class is used to look for matching rules in the caches
            by executing individual rules against the site whose fallback
            code delegates here.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.RuleBuilder">
            <summary>
            Rule Builder
            
            Rule builder is produced by the action binders. The DLR finalizes them into Rules
            which are cached in the dynamic sites and provide means for fast dispatch to commonly
            invoked functionality.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.RuleBuilder.AddValidator(Microsoft.Scripting.Utils.Function{System.Boolean})">
            <summary>
            Adds a validation delegate which determines if the rule is still valid.
            
            A validator provides a dynamic test that can invalidate a rule at runtime.  
            The definition of an invalid rule is one whose Test will always return false.  
            In theory a set of validators is not needed as this could be encoded in the 
            test itself; however, in practice it is much simpler to include these helpers.
            
            The validator returns true if the rule should still be considered valid.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.RuleBuilder.GetTemporary(System.Type,System.String)">
            <summary>
            Allocates a temporary variable for use during the rule.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.RuleBuilder.Test">
            <summary>
            An expression that should return true iff Target should be executed
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.RuleBuilder.Target">
            <summary>
            The code to execute if the Test is true.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.RuleBuilder.Parameters">
            <summary>
            Gets the logical parameters to the dynamic site in the form of Expressions.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.RuleBuilder.ParameterCount">
            <summary>
            Gets the number of logical parameters the dynamic site is provided with.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.RuleBuilder`1">
            <summary>
            A rule is the mechanism that LanguageBinders use to specify both what code to execute (the Target)
            for a particular action on a particular set of objects, but also a Test that guards the Target.
            Whenver the Test returns true, it is assumed that the Target will be the correct action to
            take on the arguments.
            
            In the current design, a RuleBuilder is also used to provide a mini binding scope for the
            parameters and temporary variables that might be needed by the Test and Target.  This will
            probably change in the future as we unify around the notion of Lambdas.
            </summary>
            <typeparam name="T">The type of delegate for the DynamicSites this rule may apply to.</typeparam>
        </member>
        <member name="F:Microsoft.Scripting.Actions.RuleBuilder`1._rule">
            <summary>
            Completed rule
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.MethodBinderContext">
            <summary>
            Helper class for emitting calls via the MethodBinder.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.PerfTrack">
            <summary>
            This class is useful for quickly collecting performance counts for expensive
            operations.  Usually this means operations involving either reflection or
            code gen.  Long-term we need to see if this can be plugged better into the
            standard performance counter architecture.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.PerfTrack.Categories.Temporary">
            <summary>
            temporary categories for quick investigation, use a custom key if you
            need to track multiple items, and if you want to keep it then create 
            a new Categories entry and rename all your temporary entries.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DlrMainCallTarget">
            <summary>
            The delegate representing the DLR Main function
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ParamsCallTarget">
            <summary>
            VB Doesn't allow params array parameters so for languages implemented in VB
            this useful delegate is here for now.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.BeginCatchBlock(System.Type)">
            <summary>
            Begins a catch block.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.BeginExceptFilterBlock">
            <summary>
            Begins an exception block for a filtered exception.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.BeginExceptionBlock">
            <summary>
            Begins an exception block for a non-filtered exception.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.BeginFaultBlock">
            <summary>
            Begins an exception fault block
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.BeginFinallyBlock">
            <summary>
            Begins a finally block
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.EndExceptionBlock">
            <summary>
            Ends an exception block.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.BeginScope">
            <summary>
            Begins a lexical scope.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.EndScope">
            <summary>
            Ends a lexical scope.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.DeclareLocal(System.Type)">
            <summary>
            Declares a local variable of the specified type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.DeclareLocal(System.Type,System.Boolean)">
            <summary>
            Declares a local variable of the specified type, optionally
            pinning the object referred to by the variable.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.DefineLabel">
            <summary>
            Declares a new label.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.MarkLabel(System.Reflection.Emit.Label)">
            <summary>
            Marks the label at the current position.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.Emit(System.Reflection.Emit.OpCode)">
            <summary>
            Emits an instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Byte)">
            <summary>
            Emits an instruction with a byte argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.ConstructorInfo)">
            <summary>
            Emits an instruction with the metadata token for the specified contructor.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Double)">
            <summary>
            Emits an instruction with a double argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.FieldInfo)">
            <summary>
            Emits an instruction with the metadata token for the specified field.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Single)">
            <summary>
            Emits an instruction with a float argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Int32)">
            <summary>
            Emits an instruction with an int argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label)">
            <summary>
            Emits an instruction with a label argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label[])">
            <summary>
            Emits an instruction with multiple target labels (switch).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.LocalBuilder)">
            <summary>
            Emits an instruction with a reference to a local variable.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Int64)">
            <summary>
            Emits an instruction with a long argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo)">
            <summary>
            Emits an instruction with the metadata token for a specified method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.SByte)">
            <summary>
            Emits an instruction with a signed byte argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Int16)">
            <summary>
            Emits an instruction with a short argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.SignatureHelper)">
            <summary>
            Emits an instruction with a signature token.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.String)">
            <summary>
            Emits an instruction with a string argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Type)">
            <summary>
            Emits an instruction with the metadata token for a specified type argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.EmitCall(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo,System.Type[])">
            <summary>
            Emits a call or a virtual call to the varargs method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.EmitCalli(System.Reflection.Emit.OpCode,System.Runtime.InteropServices.CallingConvention,System.Type,System.Type[])">
            <summary>
            Emits an unmanaged indirect call instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.EmitCalli(System.Reflection.Emit.OpCode,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])">
            <summary>
            Emits a managed indirect call instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.MarkSequencePoint(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Marks a sequence point.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.DebugILGen.UsingNamespace(System.String)">
            <summary>
            Specifies the namespace to be used in evaluating locals and watches for the
                current active lexical scope.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.LambdaCompiler">
            <summary>
            Dynamic Language Runtime Compiler.
            This part compiles lambdas.
            </summary>
            <summary>
            LambdaCompiler is responsible for compiling individual lambda (LambdaExpression). The complete tree may
            contain multiple lambdas, the Compiler class is reponsible for compiling the whole tree, individual
            lambdas are then compiled by the LambdaCompiler.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.EmitDelegateConstruction(Microsoft.Scripting.Ast.LambdaExpression,System.Type)">
            <summary>
            Emits a delegate to the method generated for the LambdaExpression.
            May end up creating a wrapper to match the requested delegate type.
            </summary>
            <param name="lambda">Lambda for which to generate a delegate</param>
            <param name="delegateType">Type of the delegate.</param>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.CreateWrapperIfNeeded(Microsoft.Scripting.Ast.LambdaCompiler,Microsoft.Scripting.Ast.LambdaExpression,System.Type)">
            <summary>
            If lambda and delegate signatures match, no need to create wrapper, otherwise
            we create wrapper and generate code to pass arguments through to the underlying method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.SignaturesMatch(System.Type[],System.Reflection.ParameterInfo[])">
            <summary>
            Signatures match if the length is the same and they have identical types.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.CreateWrapper(Microsoft.Scripting.Ast.LambdaExpression,System.Type[],System.Reflection.MethodInfo,System.Reflection.ParameterInfo[])">
            <summary>
            Creates the wrapper for the lambda to match delegate signature.
            The wrapper can have parameter array, and so can the lambda.
            
            The wrapper will propagate parameters from the wrapper into the method
            backing the lambda, extracting them from the wrapper's parameter array
            if necessary, and also (if lambda itself takes parameter array) shift the
            wrapper's parameter array to pass it down to the lambda's method.
            </summary>
            <param name="lambda">LambdaExpression compiled by lc that we are building wrapper for.</param>
            <param name="lambdaSig">Signature of the lambda (parameters only)</param>
            <param name="wrapInvoke">"Invoke" method of the wrapper delegate type.</param>
            <param name="wrapSig">The wrapper delegate signature (parameters)</param>
            <returns>LambdaCompiler for the wrapper.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.MakeParameterTypeArray(System.Collections.Generic.IList{System.Type},Microsoft.Scripting.Generation.ConstantPool,System.Boolean)">
            <summary>
            Creates the signature for the actual CLR method to create. The base types come from the
            lambda/LambdaExpression (or its wrapper method), this method may pre-pend an argument to hold
            closure information (for closing over constant pool or the lexical closure)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.ComputeSignature(Microsoft.Scripting.Ast.LambdaExpression,System.Collections.Generic.List{System.Type}@,System.Collections.Generic.List{System.String}@,System.String@)">
            <summary>
            Creates the signature for the lambda as list of types and list of names separately
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.CreateLambdaCompiler(Microsoft.Scripting.Ast.LambdaCompiler,Microsoft.Scripting.Ast.LambdaExpression,System.Boolean)">
            <summary>
            Defines the method with the correct signature and sets up the context slot appropriately.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.CreateGeneratorLambdaCompiler(Microsoft.Scripting.Ast.LambdaExpression)">
            <summary>
            Defines the method with the correct signature and sets up the context slot appropriately.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.EmitGeneratorLambdaBody">
            <summary>
            Emits the body of the function that creates a Generator object.  Also creates another
            Compiler for the inner method which implements the user code defined in the generator.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.LambdaCompiler._compiler">
            <summary>
            The compiler which contains the compilation-wide information
            such as other lambdas and their Compilers.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.LambdaCompiler._generatorInfo">
            <summary>
            The generator information for the generator being compiled.
            This is null if the current lambda is not a generator
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.LambdaCompiler._argumentSlots">
            <summary>
            Argument slots
            
            This list contains _all_ arguments on the underlying method builder (except for the
            "this"). There are two views on the list. First provides the raw view (shows all
            arguments), the second view provides view of the arguments which are in the original
            lambda (so first argument, which may be closure argument, is skipped in that case)
            
            The two views are provided by code:GetArgumentSlot (raw) and
            code:GetLambdaArgumentSlot (lambda arguments only)
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.LambdaCompiler._source">
            <summary>
            Source unit the lambda is related to (for emitting debug info)
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.LambdaCompiler._constantPoolCache">
            <summary>
            Provides access to runtime constants (raw objects) which have been
            cached in the constant pool. Dictionary uses reference equality.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.CompileTopLevelLambda(Microsoft.Scripting.SourceUnit,Microsoft.Scripting.Ast.LambdaExpression)">
            <summary>
            Compiler entry point, used by ScriptCode.
            This is used for compiling the toplevel LambdaExpression object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.CompileLambda(Microsoft.Scripting.Ast.LambdaExpression,System.Reflection.MethodInfo@,System.Type)">
            <summary>
            Compiler entry point, used by TreeCompiler
            </summary>
            <param name="lambda">LambdaExpression to compile.</param>
            <param name="method">Product of compilation</param>
            <param name="delegateType">Type of the delegate to create</param>
            <returns>The compiled delegate.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.EmitBoxing(System.Type)">
            <summary>
            Boxes the value of the stack. No-op for reference types. Void is converted to a null reference. For almost all value types this method
            will box them in the standard way.  Int32 and Boolean are handled with optimized conversions
            that reuse the same object for small values.  For Int32 this is purely a performance
            optimization.  For Boolean this is use to ensure that True and False are always the same
            objects.
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.EmitDelegateConstruction(Microsoft.Scripting.Ast.LambdaCompiler,System.Type,System.Boolean)">
            <summary>
            Emits code which creates new instance of the delegateType delegate.
            
            Since the delegate is getting closed over the "Closure" argument, this
            cannot be used with virtual/instance methods (delegateFunction must be static method)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.GetArgumentSlot(System.Int32)">
            <summary>
            Returns index-th 'raw' argument on the lambda being compiled.
            This includes possible argument at index 0 which is the closure
            for the delegate being built.
            
            For argument access which only takes into account the actual (lambda) arguments,
            use code:GetLambdaArgumentSlot
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.GetLambdaArgumentSlot(System.Int32)">
            <summary>
            Returns the index-th argument. This method provides access to the actual arguments
            defined on the lambda itself, and excludes the possible 0-th closure argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.GetLogicalArgument(System.Int32)">
            <summary>
            Gets the argument slot corresponding to the parameter at the given
            index. Assumes that the method takes a certain number of prefix
            arguments, followed by the real parameters stored in Parameters
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.GetLogicalArgument(Microsoft.Scripting.Ast.ParameterExpression)">
            <summary>
            Gets the argument slot corresponding to the parameter expression
            given. Assumes that the method takes a certain number of prefix
            arguments, followed by the real parameters stored in Parameters
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.CreateLambdaCompiler(Microsoft.Scripting.Ast.LambdaExpression,System.String,System.Type,System.Collections.Generic.IList{System.Type},System.String[],Microsoft.Scripting.Generation.ConstantPool,System.Boolean)">
            <summary>
            Creates a compiler that shares the same characteristic as "this". If compiling into
            DynamicMethod (both fake or real), it will create compiler backed by dynamic method
            (also fake or real), if compiling into a type, it will create compiler linked to
            a new (static) method on the same type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.CreateDynamicLambdaCompiler(Microsoft.Scripting.Ast.LambdaExpression,System.String,System.Type,System.Collections.Generic.IList{System.Type},Microsoft.Scripting.SourceUnit)">
            <summary>
            The internal LambdaCompiler factory to create dynamic method.
            
            Dynamic methods created this way don't have named parameters, always get constant pool,
            are not closures and don't have debug info attached.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.CreateDynamicLambdaCompiler(Microsoft.Scripting.Ast.Compiler,Microsoft.Scripting.Ast.LambdaExpression,System.String,System.Type,System.Collections.Generic.IList{System.Type},System.Collections.Generic.IList{System.String},Microsoft.Scripting.Generation.ConstantPool,System.Boolean,Microsoft.Scripting.SourceUnit)">
            <summary>
            Creates a compiler backed by dynamic method. Sometimes (when debugging is required) the dynamic
            method is actually a 'fake' dynamic method and is backed by static type created specifically for
            the one method
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.CreateStaticLambdaCompiler(Microsoft.Scripting.Ast.Compiler,Microsoft.Scripting.Ast.LambdaExpression,Microsoft.Scripting.Generation.TypeGen,System.String,System.Type,System.Collections.Generic.IList{System.Type},System.Collections.Generic.IList{System.String},Microsoft.Scripting.Generation.ConstantPool,System.Boolean)">
            <summary>
            Creates a LambdaCompiler backed by a method on a static type (represented by tg).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.CreateLambdaCompiler(Microsoft.Scripting.Ast.Compiler,Microsoft.Scripting.Ast.LambdaExpression,Microsoft.Scripting.Generation.TypeGen,System.Reflection.MethodBase,System.Reflection.Emit.ILGenerator,System.Type[])">
            <summary>
            This creates compiler designed only for type gen.
            Once TypeGen removes its dependency on LambdaCompiler, this will go away.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.EmitExpression(Microsoft.Scripting.Ast.Expression)">
            <summary>
            Generates code for this expression in a value position.
            This method will leave the value of the expression
            on the top of the stack typed as Type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.EmitExpressionAsVoid(Microsoft.Scripting.Ast.Expression)">
            <summary>
            Emits an expression and discards the result.  For some nodes this emits
            more optimial code then EmitExpression/Pop
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.EmitExpressionAsObject(Microsoft.Scripting.Ast.Expression)">
            <summary>
            Generates the code for the expression, leaving it on
            the stack typed as object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.Significant(Microsoft.Scripting.Ast.Expression)">
            <summary>
            Expression is significant if:
              * it is not an empty expression
            == or ==
              * it is an empty expression, and 
              * it has a valid span, and
              * we are emitting debug symbols
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.EmitConstantExpression(Microsoft.Scripting.Ast.LambdaCompiler,Microsoft.Scripting.Ast.Expression)">
            <summary>
            The main entry to the constant emitting.
            This will handle runtime constants.
            Constants will be left on the execution stack as their direct visible type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.EmitFinallyFlowControl(Microsoft.Scripting.Ast.TryFlowResult,Microsoft.Scripting.Generation.Slot)">
            <summary>
            If the finally statement contains break, continue, return or yield, we need to
            handle the control flow statement after we exit out of finally via OpCodes.Endfinally.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.EmitCatchStart(Microsoft.Scripting.Ast.CatchBlock)">
            <summary>
            Emits the start of a catch block.  The exception value that is provided by the
            CLR is stored in the variable specified by the catch block or popped if no
            variable is provided.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.EmitCatchStart(Microsoft.Scripting.Ast.CatchBlock,Microsoft.Scripting.Generation.Slot)">
            <summary>
            Emits the start of the catch block.  The exception value is stored in the slot
            if not null or otherwise provided in the variable of the catch block.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.EmitExpressionBranchTrue(Microsoft.Scripting.Ast.Expression,System.Reflection.Emit.Label)">
            <summary>
            This is the dual of EmitBranchFalse.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaCompiler.EmitExpressionBranchFalse(Microsoft.Scripting.Ast.Expression,System.Reflection.Emit.Label)">
            <summary>
            Generates this expression as a bool and then branches to label
            if the resulting bool is false.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaCompiler.TypeGen">
            <summary>
            Gets the TypeGen object which this Compiler is emitting into.  TypeGen can be
            null if the method is a dynamic method.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaCompiler.ConstantPool">
            <summary>
            Gets a list which can be used to inject references to objects from IL.  
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.PlatformAdaptationLayer">
            <summary>
            Abstracts system operations that are used by DLR and could potentially be platform specific.
            The host can implement its PAL to adapt DLR to the platform it is running on.
            For example, the Silverlight host adapts some file operations to work against files on the server.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.PlatformAdaptationLayer.GetFullPath(System.String)">
            <exception cref="T:System.ArgumentException">Invalid path.</exception>
        </member>
        <member name="M:Microsoft.Scripting.PlatformAdaptationLayer.IsAbsolutePath(System.String)">
            <exception cref="T:System.ArgumentException">Invalid path.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Ast.TreeComparer.Compare(Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.Expression,System.Collections.Generic.List{Microsoft.Scripting.Ast.ConstantExpression}@,System.Boolean@)">
            <summary>
            Compares two trees.  If the trees differ only by constants then the list of constants which differ
            is provided as a list via an out-param.  The constants collected are the constants in the left
            side of the tree and only include constants which differ in value.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.TreeComparer.FlatTreeWalker">
            <summary>
            Walks all of the nodes of a tree and puts all of the expressions into
            a list.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.Walker">
            <summary>
            Walker class - The DLR AST Walker
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.AutoRuleTemplate">
            <summary>
            Handles auto-templating of rules.  There are three important actions this performs:
                1. Detects if templating is possible between two rules
                2. Re-writes a non-templated rule into templated form
                3. Extracts the constants from a non-templated rule which is compatible with a 
                    templated rule so that they can be used by the existing generated code.
                    
            Auto-templating is currently only used for serially monomorphic call sites where we
            can easily avoid code gen.  It is not used for polymorphic call sites although such
            a feature could be enabled in the future.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.AutoRuleTemplate.CopyOrCreateTemplatedRule``1(Microsoft.Scripting.Actions.Rule{``0},Microsoft.Scripting.Actions.Rule{``0})">
            <summary>
            The entry point into auto-rule tempating.  This consumes the monomorphic rule which is currently
            stored in the cache as well as the rule that was just produced by the binder.  
            </summary>
            <param name="from">The original rule that is currently stored in the cache.  This rule may
            or may not be a templated rule.</param>
            <param name="to">The new rule produced by a binder.</param>
        </member>
        <member name="M:Microsoft.Scripting.Ast.AutoRuleTemplate.CloneData(System.Object,System.Object[])">
            <summary>
            Clones the delegate target to create new delegate around it.
            The delegates created by the compiler are closed over the instance of Closure class.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.SimpleRuleBuilder">
            <summary>
            Rule Builder
            
            Rule builder is produced by the action binders. The DLR finalizes them into Rules
            which are cached in the dynamic sites and provide means for fast dispatch to commonly
            invoked functionality.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.SimpleRuleBuilder._compile">
            <summary>
            List of compile time parameter types (extracted from the delegate type)
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.SimpleRuleBuilder._runtime">
            <summary>
            List of runtime parameter types (extracted from the actual runtime values)
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.SimpleRuleBuilder._parameters">
            <summary>
            Representation of the parameters to the dynamic operation
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.SimpleRuleBuilder._params">
            <summary>
            The array of parameters. This is wrapped in the ReadOnlyCollection above
            for public consumption.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.SimpleRuleBuilder._returnType">
            <summary>
            Return type of the rule
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.SimpleRuleBuilder._test">
            <summary>
            Test which determines whether this rule is applicable to the parameters
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.SimpleRuleBuilder._target">
            <summary>
            The actual operation to be performed on the parameters
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.SimpleRuleBuilder.#ctor(System.Type,System.Object[])">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.SimpleRuleBuilder.#ctor(System.Type,System.Collections.ObjectModel.ReadOnlyCollection{System.Type})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.SimpleRuleBuilder.Return(Microsoft.Scripting.Ast.Expression)">
            <summary>
            Sets the Target to the value, plus adds conversion if necessary.
            </summary>
            <param name="value">Value to return from the rule</param>
        </member>
        <member name="M:Microsoft.Scripting.Actions.SimpleRuleBuilder.CreateRuntimeTypeTest">
            <summary>
            Creates Default test
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.SimpleRuleBuilder.AddToTest(Microsoft.Scripting.Ast.Expression)">
            <summary>
            Adds a condition to a test.
            </summary>
            <param name="test"></param>
        </member>
        <member name="M:Microsoft.Scripting.Actions.SimpleRuleBuilder.CreateOneTest(Microsoft.Scripting.Ast.ParameterExpression,System.Type)">
            <summary>
            Creates one type identity test 
            </summary>
            <param name="parameter">Expression representing the rule's parameter</param>
            <param name="rt">The runtime type of the value</param>
            <returns>Expression or null if no test necessary.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.SimpleRuleBuilder.CreateTest(System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.Scripting.Ast.ParameterExpression},System.Collections.ObjectModel.ReadOnlyCollection{System.Type})">
            <summary>
            Creates standard type identity test.
            </summary>
            <param name="parameters">Parameter expressions representing the rule's parameters</param>
            <param name="runtime">Runtime types of the actual arguments</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Scripting.Actions.SimpleRuleBuilder.RuntimeTypes">
            <summary>
            Runtime types of the arguments actually passed in to the operation.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.SimpleRuleBuilder.CompileTimeTypes">
            <summary>
            Compile time types of the arguments (determined from the delegate type)
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.SimpleRuleBuilder.Parameters">
            <summary>
            Gets the logical parameters to the dynamic site in the form of Expressions.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.SimpleRuleBuilder.ReturnType">
            <summary>
            Return type of the rule.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.SimpleRuleBuilder.Test">
            <summary>
            Test which determines whether this rule is applicable to the parameters.
            Test must be of type bool.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.SimpleRuleBuilder.Target">
            <summary>
            The actual operation to be performed on the parameters
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.SimpleRuleBuilder`1">
            <summary>
            The generic SimpleRuleBuilder which gets specialized via the delegate type
            of the site it serves.
            </summary>
            <typeparam name="T">Delegate type</typeparam>
        </member>
        <member name="M:Microsoft.Scripting.Actions.SimpleRuleBuilder`1.CreateRule">
            <summary>
            Completes the rule from the builder.
            </summary>
            <returns>New rule</returns>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Rule`1._mySet">
            <summary>
            The rule set that includes only this rule.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Rule`1._parameters">
            <summary>
            The parameters to the rule
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Rule`1._binding">
            <summary>
            The binding expression tree
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Rule`1._validator">
            <summary>
            The validator to indicate when the rule is no longer valid
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Rule`1._template">
            <summary>
            Template data - null for methods which aren't templated.  Non-null for methods which
            have been templated.  The same template data is shared across all templated rules with
            the same target method.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Rule`1.RuleSet">
            <summary>
            Each rule holds onto an immutable RuleSet that contains this rule only.
            This should heavily optimize monomorphic call sites.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Rule`1.Parameters">
            <summary>
            Gets the logical parameters to the dynamic site in the form of Variables.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Rule`1.Binding">
            <summary>
            The expression representing the bound operation
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Rule`1.IsValid">
            <summary>
            If not valid, this indicates that the given Test can never return true and therefore
            this rule should be removed from any RuleSets when convenient in order to 
            reduce memory usage and the number of active rules.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Rule`1.TemplateMethod">
            <summary>
            Gets or sets the method which is used for templating. If the rule is
            not templated then this is a nop (and returns null for the getter).
            
            The method is tracked here independently from the delegate for the
            common case of the method being a DynamicMethod.  In order to re-bind
            the existing DynamicMethod to a new set of templated parameters we need
            to have the original method.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.TemplateData`1">
            <summary>
            Data used for tracking templating information in a rule.
            
            Currently we just track the method so we can retarget to
            new constant pools.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.MatchCaller">
            <summary>
            MatchCaller allows to call match maker delegate with the signature (object, CallSite, object[])
            It is used by the call site cache lookup logic when searching for applicable rule.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MatchCaller.CreateCaller(System.Type)">
            <summary>
            Uses LCG to create method such as this:
            
            object MatchCaller(object target, CallSite site, object[] args) {
                 return ((ActualDelegateType)target)(site, args[0], args[1], args[2], ...);
            }
            
            inserting appropriate casts and boxings as needed.
            </summary>
            <param name="type">Type of the delegate to call</param>
            <returns>A MatchCallerTarget delegate.</returns>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComDispatch.ComObjectWithTypeInfo">
             <summary>
             A COM object can expose its type information in two ways:
             1. IProvideClassInfo
             2. IDispatch.GetTypeInfo
             If we can determine the COM type, we can cast the object to this COM type to perform operations.
            
             Note that the CLR tries to associate strong type information (metadata) with COM objects if
             possible. ComObjectWithTypeInfo tries to provide similar functionality. However, it can try even
             harder.
             </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.ComObjectWithTypeInfo.PublishComTypes(System.Reflection.Assembly)">
            <summary>
            When an (interop) assembly is loaded, we scan it to discover the GUIDs of COM interfaces so that we can
            associate the type definition with COM objects with that GUID.
            Since scanning all loaded assemblies can be expensive, in the future, we might consider a more explicit 
            user action to trigger scanning of COM types.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.ComObjectWithTypeInfo.GetMemberBinder`1.GetFailureStatement(System.Type,System.String)">
            <summary>
            Generate the failure Statement
                if Action.IsNoThrow = True
                    OperationFailed.Value 
                else
                    MakeMissingMemberError -> returns Undefined.Value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.ResourceUtilsDescriptionAttribute.#ctor(System.String)">
            <summary>
                Constructs a new sys description.
            </summary>
            <param name='description'>
                description text.
            </param>
        </member>
        <member name="P:Microsoft.Scripting.ResourceUtilsDescriptionAttribute.Description">
            <summary>
                Retrieves the description text.
            </summary>
            <returns>
                description
            </returns>
        </member>
        <member name="T:Microsoft.Scripting.ResourceUtils">
             <summary>
                AutoGenerated resource class. Usage:
            
                    string s = ResourceUtils.GetString(ResourceUtils.MyIdenfitier);
             </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.ListStack`1">
            <summary>
            A stack implemented as a list. Allows both Push/Pop access and indexing into any member of the list.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ListStack`1.Peek">
            <exception cref="T:System.InvalidOperationException">Stack is empty.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ListStack`1.Pop">
            <exception cref="T:System.InvalidOperationException">Stack is empty.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ListStack`1.GetEnumerator">
            <summary>
            Enumerates from the top of the stack to the bottom.
            </summary>
            <exception cref="T:System.InvalidOperationException">Stack has been modified during enumeration.</exception>
        </member>
        <member name="P:Microsoft.Scripting.Generation.ConstantPool.IsBound">
            <summary>
            True if the ConstantPool will be bound as the 1st argument to a delegate.  False
            if the constant pool storage will always go into static fields.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.SourceCodeKind">
            <summary>
            Defines a kind of the source code. The parser sets its initial state accordingly.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceCodeKind.Expression">
            <summary>
            The code is an expression.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceCodeKind.Statements">
            <summary>
            The code is a sequence of statements.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceCodeKind.SingleStatement">
            <summary>
            The code is a single statement.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceCodeKind.File">
            <summary>
            The code is a content of a file.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceCodeKind.InteractiveCode">
            <summary>
            The code is an interactive command.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ScriptCode">
            <summary>
            ScriptCode is an instance of compiled code that is bound to a specific LanguageContext
            but not a specific ScriptScope.  The code can be re-executed multiple times in different
            contexts. Hosting API counterpart for this class is <c>CompiledCode</c>.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ScriptCode.CompileOptimizedScope">
            <summary>
            Creates the methods and optimized Scope's which get associated with each ScriptCode.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ScriptCode.SaveToDisk(System.String,Microsoft.Scripting.ScriptCode[])">
            <summary>
            This takes an assembly name including extension and saves the provided ScriptCode objects into the assembly.  
            
            The provided script codes can constitute code from multiple languages.  The assemblyName can be either a fully qualified 
            or a relative path.  The DLR will simply save the assembly to the desired location.  The assembly is created by the DLR and 
            if a file already exists than an exception is raised.  
            
            The DLR determines the internal format of the ScriptCode and the DLR can feel free to rev this as appropriate.  
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ScriptCode.LoadFromAssembly(Microsoft.Scripting.Runtime.ScriptDomainManager,System.Reflection.Assembly)">
            <summary>
            This will take an assembly object which the user has loaded and return a new set of ScriptCode?s which have 
            been loaded into the provided ScriptDomainManager.  
            
            If the language associated with the ScriptCode?s has not already been loaded the DLR will load the 
            LanguageContext into the ScriptDomainManager based upon the saved LanguageContext type.  
            
            If the LanguageContext or the version of the DLR the language was compiled against is unavailable a 
            TypeLoadException will be raised unless policy has been applied by the administrator to redirect bindings.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.VariableExpression">
            <summary>
            VariableExpression represents actual memory/dictionary location in the generated code.
            </summary>    
        </member>
        <member name="T:Microsoft.Scripting.Ast.BreakStatement">
            <summary>
            Breaks to the end of the the target LabeledStatement
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.AbstractContext">
            <summary>
            An abstraction of an evaluation CodeContext
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.ParameterExpression._hidden">
            <summary>
            Hidden parameter, one that is not visible by name in the scope frames
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.RuleSet`1">
            <summary>
            A RuleSet is a collection of rules to apply to the objects at a DynamicSite.  Each Rule also
            includes a target that is to be called if the rules' conditions are met.
            RuleSets are all immutable.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.MemberGroup">
            <summary>
            MemberGroups are a collection of MemberTrackers which are commonly produced
            on-demand to talk about the available members.  They can consist of a mix of
            different member types or multiple membes of the same type.
            
            The most common source of MemberGroups is from ActionBinder.GetMember.  From here
            the DLR will perform binding to the MemberTrackers frequently producing the value
            resulted from the user.  If the result of the action produces a member it's self
            the ActionBinder can provide the value exposed to the user via ReturnMemberTracker.
            
            ActionBinder provides default functionality for both getting members from a type
            as well as exposing the members to the user.  Getting members from the type maps
            closely to reflection and exposing them to the user exposes the MemberTrackers
            directly.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.CodeContextExpression">
            <summary>
            Evaluates to the CodeContext that's currently in scope
            
            TODO: move to Microsoft.Scripting !!!
            TODO: this should go away as an intrinsic in favor of languages
                  tracking their own scope chain explicitly
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.CodeContextScopeExpression">
            <summary>
            Creates a new scope where the specified CodeContext will be valid
            
            TODO: move to Microsoft.Scripting !!!
            TODO: this should go away as an intrinsic in favor of languages
                  tracking their own scope chain explicitly
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.CodeContextScopeExpression.Body">
            <summary>
            The body where the new CodeContext can be used
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.CodeContextScopeExpression.NewContext">
            <summary>
            The expression that initializes the new CodeContext for this scope
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComDispatch.ComParamDesc">
            <summary>
            The parameter description of a method defined in a type library
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.ComParamDesc.#ctor(System.Runtime.InteropServices.ComTypes.ELEMDESC@,System.String)">
            <summary>
            Creates a representation for the paramter of a COM method
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.ComParamDesc.#ctor(System.Runtime.InteropServices.ComTypes.ELEMDESC@)">
            <summary>
            Creates a representation for the return value of a COM method
            TODO: Return values should be represented by a different type
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.ComDispatch.ComParamDesc.DefaultValue">
            <summary>
            DBNull.Value if there is no default value
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.CodeContext">
            <summary>
            TODO: Rename to LocalScope
            </summary>    
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ModuleGlobalCache">
            <summary>
            Cached global value.  Created and maintained on a per-language basis.  Default
            implementation returns a singleton which indicates caching is not occuring.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ModuleGlobalCache.#ctor(System.Object)">
            <summary>
            Creates a new ModuleGlobalCache with the specified value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ModuleGlobalCache.Changed(System.Object,Microsoft.Scripting.Runtime.ModuleChangeEventArgs)">
            <summary>
            Event handler for when the value has changed.  Language implementors should call this when
            the cached value is invalidated.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ModuleGlobalCache.IsCaching">
            <summary>
            True if the ModuleGlobalCache is participating in a caching strategy.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ModuleGlobalCache.HasValue">
            <summary>
            True if their is currently a value associated with this global variable.  False if
            it is currently unassigned.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ModuleGlobalCache.Value">
            <summary>
            Gets or sets the current cached value
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.NarrowingLevel">
            <summary>
            Narrowing conversions are conversions that cannot be proved to always succeed, conversions that are 
            known to possibly lose information, and conversions across domains of types sufficiently different 
            to merit narrowing notation like casts. 
            
            Its upto every language to define the levels for conversions. The narrowling levels can be used by
            for method overload resolution, where the overload is based on the parameter types (and not the number 
            of parameters).
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Generation.NarrowingLevel.None">
            <summary>
            Conversions at this level do not do any narrowing. Typically, this will include
            implicit numeric conversions, Type.IsAssignableFrom, StringBuilder to string, etc.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Generation.NarrowingLevel.One">
            <summary>
            Language defined prefered narrowing conversion.  First level that introduces narrowing
            conversions.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Generation.NarrowingLevel.Two">
            <summary>
            Language defined preferred narrowing conversion.  Second level that introduces narrowing
            conversions and should have more conversions than One.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Generation.NarrowingLevel.Three">
            <summary>
            Language defined preferred narrowing conversion.  Third level that introduces narrowing
            conversions and should have more conversions that Two.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Generation.NarrowingLevel.All">
            <summary>
            A somewhat meaningful conversion is possible, but it will quite likely be lossy.
            For eg. BigInteger to an Int32, Boolean to Int32, one-char string to a char,
            larger number type to a smaller numeric type (where there is no overflow), etc
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.PropertyTracker">
            <summary>
            Represents a logical Property as a member of a Type.  This Property can either be a real 
            concrete Property on a type (implemented with a ReflectedPropertyTracker) or an extension
            property (implemented with an ExtensionPropertyTracker).
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ReflectionCache">
            <summary>
            Provides a cache of reflection members.  Only one set of values is ever handed out per a 
            specific request.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ReflectionCache.GetMethodGroup(System.Type,System.String,System.Reflection.BindingFlags,System.Reflection.MemberFilter)">
            <summary>
            Gets a singleton method group from the provided type.
            
            The provided method group will be unique based upon the methods defined, not based upon the type/name
            combination.  In other words calling GetMethodGroup on a base type and a derived type that introduces
            no new methods under a given name will result in the same method group for both types.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ReflectionCache.MethodBaseCache">
            <summary>
            TODO: Make me private again
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.ParameterInfoWrapper">
            <summary>
            This helper type lets us build a fake ParameterInfo object with a specific type and name
            to pass along to methods that expect ParameterInfos.  This is currently found useful
            for the NewTypeMaker code and may be useful in other situations as well.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.CastSlot">
            <summary>
            A slot that can be used to wrap other slots and perform a cast before
            getting or setting the value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LoopStatement.#ctor(Microsoft.Scripting.Ast.Annotations,Microsoft.Scripting.Ast.LabelTarget,Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.Expression)">
            <summary>
            Null test means infinite loop.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.MemberExpression">
            <summary>
            Member expression (statically typed) which represents 
            property or field access, both static and instance.
            For instance property/field, Expression must be != null.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.LabeledStatement">
            <summary>
            Represents a labeled statement
            break and continue statements will jump to the end of body
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.StackSpiller">
            <summary>
            Expression rewriting to spill the CLR stack into temporary variables
            in order to guarantee some properties of code generation, for
            example that we always enter try block on empty stack.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.StackSpiller._tm">
            <summary>
            The source of temporary variables
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.StackSpiller.AnalyzeLambda(Microsoft.Scripting.Ast.LambdaExpression)">
            <summary>
            Analyzes a lambda, producing a new one that has correct invariants
            for codegen. In particular, it spills the IL stack to temps in
            places where it's invalid to have a non-empty stack (for example,
            entering a try statement).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.StackSpiller.RewriteExpression(Microsoft.Scripting.Ast.StackSpiller,Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.StackSpiller.Stack)">
            <summary>
            Rewrite the expression
            </summary>
            <param name="self">Expression rewriter instance</param>
            <param name="node">Expression to rewrite</param>
            <param name="stack">State of the stack before the expression is emitted.</param>
            <returns>Rewritten expression.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.StackSpiller.Clone``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Int32)">
            <summary>
            Will clone an IList into an array of the same size, and copy
            all vaues up to (and NOT including) the max index
            </summary>
            <returns>The cloned array.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.StackSpiller.ToTemp(Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.Expression@)">
            <summary>
            Will perform:
                save: temp = expression
                return value: temp
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.StackSpiller.TempMaker._temp">
            <summary>
            Current temporary variable
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.StackSpiller.TempMaker._freeTemps">
            <summary>
            List of free temporary variables. These can be recycled for new temps.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.StackSpiller.TempMaker._usedTemps">
            <summary>
            Stack of currently active temporary variables.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.StackSpiller.TempMaker._temps">
            <summary>
            List of all temps created by stackspiller for this rule/lambda
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.StackSpiller.ChildRewriter">
            <summary>
            Rewrites child expressions, spilling them into temps if needed. The
            stack starts in the inital state, and after the first subexpression
            is added it is change to non-empty. This behavior can be overriden
            by setting the stack manually between adds.
            
            When all children have been added, the caller should rewrite the 
            node if Rewrite is true. Then, it should call crFinish with etiher
            the orignal expression or the rewritten expression. Finish will call
            Expression.Comma if necessary and return a new Result.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ILocalVariables">
            <summary>
            Provides read/write access to variables in a scope.
            Created by LocalScopeExpression
            
            TODO: review public API
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.SymbolDictionary">
            <summary>
            Simple thread-safe SymbolDictionary used for storing collections of members.
            
            Like all SymbolDictionaries this supports both indexing using SymbolId's (IAttributesCollection)
            and via object keys (IDictionary&lt;object, object&gt;).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.SymbolDictionary.GetObjectKeysDictionary">
            <summary>
            Symbol dictionaries are usually indexed using literal strings, which is handled using the Symbols.
            However, some languages allow non-string keys too. We handle this case by lazily creating an object-keyed dictionary,
            and keeping it in the symbol-indexed dictionary. Such access is slower, which is acceptable.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DynamicStackFrame">
            <summary>
            Helper for storing information about stack frames.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ModuleChangeEventArgs">
            <summary>
            Event args for when a ScriptScope has had its contents changed.  
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ModuleChangeEventArgs.#ctor(Microsoft.Scripting.SymbolId,Microsoft.Scripting.Runtime.ModuleChangeType)">
            <summary>
            Creates a new ModuleChangeEventArgs object with the specified name and type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ModuleChangeEventArgs.#ctor(Microsoft.Scripting.SymbolId,Microsoft.Scripting.Runtime.ModuleChangeType,System.Object)">
            <summary>
            Creates a nwe ModuleChangeEventArgs with the specified name, type, and changed value.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ModuleChangeEventArgs.Name">
            <summary>
            Gets the name of the symbol that has changed.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ModuleChangeEventArgs.ChangeType">
            <summary>
            Gets the way in which the symbol has changed: Set or Delete.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ModuleChangeEventArgs.Value">
            <summary>
            The the symbol has been set provides the new value.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.OperatorSlotAttribute">
            <summary>
            Represents an ops-extension method which is added as an operator.
            
            The name must be a well-formed name such as "Add" that matches the CLS
            naming conventions for adding overloads associated with op_* methods.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.FieldSlot">
            <summary>
            FieldSlot is an access of an attribute of an object 
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Generation.FieldSlot.Instance">
            <summary>
            Gets the slot that is used for the instance of the field
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Generation.FieldSlot.Field">
            <summary>
            Gets the FieldInfo for which this slot loads its value
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.CallSite">
            <summary>
            A Dynamic Call Site base class. This type is used as a parameter type to the
            dynamic site targets. The first parameter of the delegate (T) below must be
            of this type.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.CallSite._binder">
            <summary>
            The Binder responsible for binding operations at this call site.
            This binder is invoked by the UpdateAndExecute below if all Level 0,
            Level 1 and Level 2 caches experience cache miss.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.CallSite.Binder">
            <summary>
            Class responsible for binding dynamic operations on the dynamic site.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.CallSite`1">
            <summary>
            Dynamic site type.
            </summary>
            <typeparam name="T">The delegate type.</typeparam>
        </member>
        <member name="F:Microsoft.Scripting.Actions.CallSite`1._update">
            <summary>
            The update delegate. Called when the dynamic site experiences cache miss
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.CallSite`1._target">
            <summary>
            The Level 0 cache - a delegate specialized based on the site history.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.CallSite`1._rules">
            <summary>
            The Level 1 cache - a history of the dynamic site
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.CallSite`1._cache">
            <summary>
            The Level 2 cache - all rules produced for the same generic instantiation
            of the dynamic site (all dynamic sites with matching delegate type).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.CallSite`1.UpdateAndExecute(System.Object[])">
            <summary>
            Gets a rule, updates the site that called, and then returns the result of executing the rule.
            
            This method is called on a level 0 cache miss.
            </summary>
            <param name="args">The arguments to the rule as provided from the call site at runtime.</param>
            <returns>The result of executing the rule.</returns>
        </member>
        <member name="T:Microsoft.Scripting.Ast.LambdaExpression">
            <summary>
            This captures a block of code that should correspond to a .NET method body.  It takes
            input through parameters and is expected to be fully bound.  This code can then be
            generated in a variety of ways.  The variables can be kept as .NET locals or in a
            1st class environment object. This is the primary unit used for passing around
            Expression Trees in the DLR.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.CompilerOptions">
            <summary>
            TODO - If this class is really this simple, do we need it at all?
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.ReferenceArgBuilder">
            <summary>
            An argument that the user wants to explicitly pass by-reference (with copy-in copy-out semantics).
            The user passes a StrongBox[T] object whose value will get updated when the call returns.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.SimpleArgBuilder">
            <summary>
            SimpleArgBuilder produces the value produced by the user as the argument value.  It
            also tracks information about the original parameter and is used to create extended
            methods for params arrays and param dictionary functions.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ArgumentInfo">
            <summary>
            TODO: Alternatively, it should be sufficient to remember indices for this, list, dict and block.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SymbolId.ToString">
            <summary>
            Override of ToString.
            DO NOT USE THIS METHOD TO RETRIEVE STRING THAT THE SYMBOL REPRESENTS
            Use SymbolTable.IdToString(SymbolId) instead.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SymbolId.Empty">
            <summary>SymbolId for null string</summary>
        </member>
        <member name="F:Microsoft.Scripting.SymbolId.Invalid">
            <summary>SymbolId to represent invalid value</summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.SynchronizedDictionary`2">
            <summary>
            Dictionary[TKey, TValue] is not thread-safe in the face of concurrent reads and writes. SynchronizedDictionary
            provides a thread-safe implementation. It holds onto a Dictionary[TKey, TValue] instead of inheriting from
            it so that users who need to do manual synchronization can access the underlying Dictionary[TKey, TValue].
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Utils.SynchronizedDictionary`2.UnderlyingDictionary">
            <summary>
            This returns the raw unsynchronized Dictionary[TKey, TValue]. Users are responsible for locking
            on it before accessing it. Also, it should not be arbitrarily handed out to other code since deadlocks
            can be caused if other code incorrectly locks on it.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Generation.TypeGen.TypeInitializer">
            <summary>
            Gets the Compiler associated with the Type Initializer (cctor) creating it if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.IsMandatoryParameter(System.Reflection.ParameterInfo)">
            <summary>
            Returns <c>true</c> if the specified parameter is mandatory, i.e. is not optional and doesn't have a default value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.IsConstructor(System.Reflection.MethodBase)">
            <summary>
            True if the MethodBase is method which is going to construct an object
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.IsSealed(System.Type)">
            <summary>
            A helper routine to check if a type can be treated as sealed - i.e. there
            can never be a subtype of this given type.  This corresponds to a type
            that is either declared "Sealed" or is a ValueType and thus unable to be
            extended.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.GetType(System.Object)">
            <summary>
            Returns the System.Type for any object, including null.  The type of null
            is represented by None.Type and all other objects just return the 
            result of Object.GetType
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.GetTypes(System.Object[])">
            <summary>
            Simply returns a Type[] from calling GetType on each element of args.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.TryGetCallableMethod(System.Reflection.MethodInfo)">
            <summary>
            Given a MethodInfo which may be declared on a non-public type this attempts to
            return a MethodInfo which will dispatch to the original MethodInfo but is declared
            on a public type.
            
            Returns null if a public method cannot be obtained.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.FilterNonVisibleMembers(System.Type,System.Reflection.MemberInfo[])">
            <summary>
            Non-public types can have public members that we find when calling type.GetMember(...).  This
            filters out the non-visible members by attempting to resolve them to the correct visible type.
            
            If no correct visible type can be found then the member is not visible and we won't call it.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.GetCallableMethod(System.Reflection.MethodInfo)">
            <summary>
            Given a MethodInfo which may be declared on a non-public type this attempts to
            return a MethodInfo which will dispatch to the original MethodInfo but is declared
            on a public type.
            
            Throws InvalidOperationException if the method cannot be obtained.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.GetTryConvertReturnValue(Microsoft.Scripting.Runtime.CodeContext,Microsoft.Scripting.Actions.RuleBuilder)">
            <summary>
            Returns a value which indicates failure when a ConvertToAction of ImplicitTry or
            ExplicitTry.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.LocalVariableAccess">
            <summary>
            Provides a list of local variables, supporing read/write of elements
            Exposed via LocalScopeExpression
            
            TODO: This will get simpler when we stop merging scopes in the compiler
                  (then we'll only need to store two arrays)
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.ToDiskRewriter">
            <summary>
            Serializes constants and dynamic sites so the code can be saved to disk
            TODO: move to Microsoft.Scripting !!!
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.GlobalArrayRewriter">
            <summary>
            Rewrites globals to elements on a closed over array
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComDispatch.VarEnumSelector">
            <summary>
            If a managed user type (as opposed to a primitive type or a COM object) is passed as an argument to a COM call, we need
            to determine the VarEnum type we will marshal it as. We have the following options:
            1.	Raise an exception. Languages with their own version of primitive types would not be able to call
                COM methods using the language's types (for eg. strings in IronRuby are not System.String). An explicit
                cast would be needed.
            2.	We could marshal it as VT_DISPATCH. Then COM code will be able to access all the APIs in a late-bound manner,
                but old COM components will probably malfunction if they expect a primitive type.
            3.	We could guess which primitive type is the closest match. This will make COM components be as easily 
                accessible as .NET methods.
            4.	We could use the type library to check what the expected type is. However, the type library may not be available.
            
            VarEnumSelector implements option # 3
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.VarEnumSelector.#ctor(Microsoft.Scripting.Actions.ActionBinder,System.Type,System.Object[])">
            <summary>
            This constructor infers the COM types to marshal the arguments to based on
            the conversions supported for the given argument type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.VarEnumSelector.BuildArguments(Microsoft.Scripting.Runtime.CodeContext,System.Object[],System.Reflection.ParameterModifier@)">
            <summary>
            Gets the arguments ready for marshaling to COM
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.VarEnumSelector.GetManagedMarshalType(System.Runtime.InteropServices.VarEnum)">
            <summary>
            Gets the managed type that an object needs to be coverted to in order for it to be able
            to be represented as a Variant.
            
            In general, there is a many-to-many mapping between Type and VarEnum. However, this method
            returns a simple mapping that is needed for the current implementation. The reason for the 
            many-to-many relation is:
            1. Int32 maps to VT_I4 as well as VT_ERROR, and Decimal maps to VT_DECIMAL and VT_CY. However,
               this changes if you throw the wrapper types into the mix.
            2. There is no Type to represent COM types. __ComObject is a private type, and Object is too
               general.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.VarEnumSelector.CreateComPrimitiveTypeFamilies">
            <summary>
            Creates a family of COM types such that within each family, there is a completely non-lossy
            conversion from a type to an earlier type in the family.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.VarEnumSelector.GetConversionsToComPrimitiveTypeFamilies(System.Type,Microsoft.Scripting.Generation.NarrowingLevel)">
            <summary>
            Get the (one representative type for each) primitive type families that the argument can be converted to
            at the given NarrowingLevel.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.VarEnumSelector.CheckForAmbiguousMatch(System.Type,System.Collections.Generic.List{System.Runtime.InteropServices.VarEnum})">
            <summary>
            If there is more than one type family that the argument can be converted to, we will throw a
            AmbiguousMatchException instead of randomly picking a winner.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.VarEnumSelector.TryGetPrimitiveComType(System.Type,System.Runtime.InteropServices.VarEnum@)">
            <summary>
            Is there a unique primitive type that has the best conversion for the argument
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.VarEnumSelector.GetComType(System.Int32,System.Type,Microsoft.Scripting.Generation.ArgBuilder@)">
            <summary>
            Get the COM Variant type that argument should be marshaled as for a call to COM
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.ComDispatch.VarEnumSelector.IsSupportedByFastPath">
            <summary>
            Can IDispatchCallBinderHelper generate an optimized DynamicSite, or should we fall back
            to the slow DispCallable.UpoptimizedInvoke
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.NullArgBuilder">
            <summary>
            ArgBuilder which always produces null.  
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.StringUtils.SplitWords(System.String,System.Boolean,System.Int32)">
            <summary>
            Splits text and optionally indents first lines - breaks along words, not characters.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.SharedIO.SetOutput(System.IO.Stream,System.IO.TextWriter)">
            <summary>
            Only host should redirect I/O.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ModuleGlobalWrapper">
            <summary>
            Provides cached global variable for modules to enable optimized access to
            module globals.  Both the module global value and the cached value can be held
            onto and the cached value can be invalidated by the providing LanguageContext.
            
            The cached value is provided by the LanguageContext.GetModuleCache API.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.CompilerContext">
            <summary>
            Represents the context that is flowed for doing Compiler.  Languages can derive
            from this class to provide additional contextual information.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.CompilerContext._sourceUnit">
            <summary>
            Source unit currently being compiled in the CompilerContext
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.CompilerContext._errors">
            <summary>
            Current error sink.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.CompilerContext._parserSink">
            <summary>
            Sink for parser callbacks (e.g. brace matching, etc.).
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.CompilerContext._options">
            <summary>
            Compiler specific options.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.NullTextContentProvider">
            <summary>
            A NullTextContentProvider to be provided when we have a pre-compiled ScriptCode which doesn't
            have source code associated with it.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.StaticFieldSlot">
            <summary>
            A slot backed by a static field in a type
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Generation.StaticFieldSlot.Field">
            <summary>
            Gets the FieldInfo for which this slot will emit a get / set for.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DynamicRuntimeHostingProvider">
            <summary>
            DLR requires any Hosting API provider to implement this class and provide its instance upon Runtime initialization.
            DLR calls on it to perform basic host/system dependent operations.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicRuntimeHostingProvider.TryGetSourceFileUnit(Microsoft.Scripting.Runtime.LanguageContext,System.String,System.Text.Encoding,Microsoft.Scripting.SourceCodeKind)">
            <summary>
            Gets SourceUnit corresponding to a source file on a specifed path.
            The result is associated with the given language (engine) and encoding.
            The format of the path is host defined.
            </summary>
            <exception cref="T:System.ArgumentNullException">Engine, path or encoding is a <c>null</c> reference.</exception>
            <returns>Null, if the source file doesn't exist.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicRuntimeHostingProvider.ResolveSourceFileUnit(System.String)">
            <summary>
            Resolves the given name to a source unit.
            </summary>
            <exception cref="T:System.IO.FileNotFoundException">No file matches the specified name.</exception>
            <exception cref="T:System.ArgumentNullException">Name is a <c>null</c> reference.</exception>
            <exception cref="T:System.ArgumentException">Name is not valid.</exception>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.DynamicRuntimeHostingProvider.PlatformAdaptationLayer">
            <summary>
            Abstracts system operations that are used by DLR and could potentially be platform specific.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.TryStatement.#ctor(Microsoft.Scripting.Ast.Annotations,Microsoft.Scripting.Ast.Expression,System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.Scripting.Ast.CatchBlock},Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.Expression)">
            <summary>
            Called by <see cref="T:Microsoft.Scripting.Ast.TryStatementBuilder"/>.
            Creates a try/catch/finally/else block.
            
            The body is protected by the try block.
            The handlers consist of a set of language-dependent tests which call into the LanguageContext.
            The elseSuite runs if no exception is thrown.
            The finallySuite runs regardless of how control exits the body.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.DeleteExpression">
            <summary>
            AST node representing dynamic deletion.
            
            Supported lvalue types:
                MemberExpression
                (future) BinaryExpression with NodeType == ArrayIndex
                (future) IndexedPropertyExpression
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.Compiler">
            <summary>
            The object responsible for compiling the whole tree. The tree may contain multiple lambdas
            Each of the individual lambdas is compiled by the LambdaCompiler.
            The LambdaCompilers used to compile the tree are cached inside _compilers dictionary.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.Compiler._compilers">
            <summary>
            The dictionary of all compilers that are compiling individual lambdas.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.Compiler._at">
            <summary>
            Analyzed tree - the binding information etc.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Compiler.ProvideLambdaImplementation(Microsoft.Scripting.Ast.LambdaCompiler,Microsoft.Scripting.Ast.LambdaExpression,System.Boolean)">
            <summary>
            Returns the Compiler implementing the lambda.
            Emits the lambda implementation if it hasn't been emitted yet.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Compiler.GetScopeInfo(Microsoft.Scripting.Ast.Expression)">
            <summary>
            Finds the ScopeInfo for the given scope in the AnalyzedTree.
            Returns non-null, unless the scope was merged with its parent.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Compiler.GetGeneratorInfo(Microsoft.Scripting.Ast.LambdaExpression)">
            <summary>
            Finds the GeneratorInfo for the given lambda in the
            AnalyzedTree. The lambda must be there since the _at
            came out of the analysis of the ast being compiled.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.ConstantCheck.Check(Microsoft.Scripting.Ast.Expression,System.Object)">
            <summary>
            Tests to see if the expression is a constant with the given value.
            </summary>
            <param name="expression">The expression to examine</param>
            <param name="value">The constant value to check for.</param>
            <returns>true/false</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.ConstantCheck.IsConstant(Microsoft.Scripting.Ast.Expression,System.Object)">
            <summary>
            Tests to see if the expression is a constant with the given value.
            </summary>
            <param name="e">The expression to examine</param>
            <param name="value">The constant value to check for.</param>
            <returns>true/false</returns>
        </member>
        <member name="T:Microsoft.Scripting.Ast.AnalyzedTree">
            <summary>
            This class includes all information that LambdaBinder extracted
            from the tree, and which is used for code generation.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.AnalyzedTree._infos">
            <summary>
            The dictionary of all lambdas and their infos in the tree.
            This includes both instances of LambdaExpression and GeneratorLambdaExpression
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.AnalyzedTree._generators">
            <summary>
            The dictionary of all generators and their infos in the tree.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.LanguageBoundTextContentProvider">
            <summary>
            Internal class which binds a LanguageContext, StreamContentProvider, and Encoding together to produce
            a TextContentProvider which reads binary data with the correct language semantics.
            
            TODO: currently duplicated in Microsoft.Scripting, remove this when LanguageContext moves up
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.TypeGroup">
            <summary>
            A TypeCollision is used when we have a collsion between
            two types with the same name.  Currently this is only possible w/ generic
            methods that should logically have arity as a portion of their name. For eg:
                 System.EventHandler and System.EventHandler[T]
                 System.Nullable and System.Nullable[T]
                 System.IComparable and System.IComparable[T]
            
            The TypeCollision provides an indexer but also is a real type.  When used
            as a real type it is the non-generic form of the type.
            
            The indexer allows the user to disambiguate between the generic and
            non-generic versions.  Therefore users must always provide additional
            information to get the generic version.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TypeGroup.UpdateTypeEntity(Microsoft.Scripting.Actions.TypeTracker,Microsoft.Scripting.Actions.TypeTracker)">
            <param name="existingTypeEntity">The merged list so far. Could be null</param>
            <param name="newType">The new type(s) to add to the merged list</param>
            <returns>The merged list.  Could be a TypeTracker or TypeGroup</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TypeGroup.GetGenericArity(System.Type)">
            <summary> Gets the arity of generic parameters</summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.TypeGroup.NonGenericType">
            <summary>
            This will throw an exception if all the colliding types are generic
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.TypeGroup.DeclaringType">
            <summary>
            This returns the DeclaringType of all the types in the TypeGroup
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.TypeGroup.Name">
            <summary>
            This returns the base name of the TypeGroup (the name shared by all types minus arity)
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.TypeGroup.Type">
            <summary>
            This will return the result only for the non-generic type if one exists, and will throw 
            an exception if all types in the TypeGroup are generic
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.TypeGroup.IsPublic">
            <summary>
            This will return the result only for the non-generic type if one exists, and will throw 
            an exception if all types in the TypeGroup are generic
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.SmallRuleSet`1">
            <summary>
            This holds a set of rules for a particular DynamicSite.  Any given
            SmallRuleSet instance is immutable and therefore they may be cached
            and shared.  At the moment, the only ones that are shared are
            SmallRuleSets with a single rule.
            
            When a new rule is added, then a new SmallRuleSet will be created
            that contains all existing rules that are still considered valid with
            the new rule added to the front of the list.  The target generated for
            this type will simply try each of the rules in order and emit the
            standard DynamicSite.UpdateBindingAndInvoke fallback call at the end.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Microsoft.Scripting.Actions.RuleTree`1">
            <summary>
            This uses linear search to find a rule.  Clearly that doesn't scale super well.
            We will address this in the future.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Microsoft.Scripting.Actions.RuleTree`1.FindApplicableRules(System.Type[],`0)">
            <summary>
            Looks through the rule list, prunes invalid rules and returns rules that apply
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.RuleCache`1">
            <summary>
            This is a cache of all generated rules (per dynamic site class)
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SyntaxErrorException.RawSpan">
            <summary>
            Unmapped span.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.LanguageContext">
            <summary>
            Provides language specific facilities which are typicalled called by the runtime.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.CreateScopeExtension(Microsoft.Scripting.Runtime.Scope)">
            <summary>
            Factory for ModuleContext creation. 
            It is guaranteed that this method is called once per each ScriptScope the langauge code is executed within.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.UpdateSourceCodeProperties(Microsoft.Scripting.CompilerContext)">
            <summary>
            Updates code properties of the specified source unit. 
            The default implementation invokes code parsing. 
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.GetCompilerOptions">
            <summary>
            Creates the language specific CompilerContext object for code compilation.  The 
            language should flow any relevant options from the LanguageContext to the 
            newly created CompilerContext.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.GetCompilerOptions(Microsoft.Scripting.Runtime.Scope)">
            <summary>
            Creates compiler options initialized by the options associated with the module.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.TryLookupName(Microsoft.Scripting.Runtime.CodeContext,Microsoft.Scripting.SymbolId,System.Object@)">
            <summary>
            Looks up the name in the provided Scope using the current language's semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.LookupName(Microsoft.Scripting.Runtime.CodeContext,Microsoft.Scripting.SymbolId)">
            <summary>
            Looks up the name in the provided scope using the current language's semantics.
            
            If the name cannot be found throws the language appropriate exception or returns
            the language's appropriate default value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.SetName(Microsoft.Scripting.Runtime.CodeContext,Microsoft.Scripting.SymbolId,System.Object)">
            <summary>
            Attempts to set the name in the provided scope using the current language's semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.RemoveName(Microsoft.Scripting.Runtime.CodeContext,Microsoft.Scripting.SymbolId)">
            <summary>
            Attempts to remove the name from the provided scope using the current language's semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.TryLookupGlobal(Microsoft.Scripting.Runtime.CodeContext,Microsoft.Scripting.SymbolId,System.Object@)">
            <summary>
            Attemps to lookup a global variable using the language's semantics called from
            the provided Scope.  The default implementation will attempt to lookup the variable
            at the host level.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.MissingName(Microsoft.Scripting.SymbolId)">
            <summary>
            Called when a lookup has failed and an exception should be thrown.  Enables the 
            language context to throw the appropriate exception for their language when
            name lookup fails.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.GetModuleCache(Microsoft.Scripting.SymbolId)">
            <summary>
            Returns a ModuleGlobalCache for the given name.  
            
            This cache enables fast access to global values when a SymbolId is not defined after searching the Scope's.  Usually
            a language implements lookup of the global value via TryLookupGlobal.  When GetModuleCache returns a ModuleGlobalCache
            a cached value can be used instead of calling TryLookupGlobal avoiding a possibly more expensive lookup from the 
            LanguageContext.  The ModuleGlobalCache can be held onto and have its value updated when the cache is invalidated.
            
            By default this returns a cache which indicates no caching should occur and the LanguageContext will be 
            consulted when a module value is not available. If a LanguageContext only caches some values it can return 
            the value from the base method when the value should not be cached.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.Call(Microsoft.Scripting.Runtime.CodeContext,System.Object,System.Object[])">
            <summary>
            Calls the function with given arguments
            </summary>
            <param name="context"></param>
            <param name="function">The function to call</param>
            <param name="args">The argumetns with which to call the function.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.CallWithThis(Microsoft.Scripting.Runtime.CodeContext,System.Object,System.Object,System.Object[])">
            <summary>
            Calls the function with instance as the "this" value.
            </summary>
            <param name="context"></param>
            <param name="function">The function to call</param>
            <param name="instance">The instance to pass as "this".</param>
            <param name="args">The rest of the arguments.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.CallWithArgsKeywordsTupleDict(Microsoft.Scripting.Runtime.CodeContext,System.Object,System.Object[],System.String[],System.Object,System.Object)">
            <summary>
            Calls the function with arguments, extra arguments in tuple and dictionary of keyword arguments
            </summary>
            <param name="context"></param>
            <param name="func">The function to call</param>
            <param name="args">The arguments</param>
            <param name="names">Argument names</param>
            <param name="argsTuple">tuple of extra arguments</param>
            <param name="kwDict">keyword dictionary</param>
            <returns>The result of the function call.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.CallWithArgsTuple(Microsoft.Scripting.Runtime.CodeContext,System.Object,System.Object[],System.Object)">
            <summary>
            Calls function with arguments and additional arguments in the tuple
            </summary>
            <param name="context"></param>
            <param name="func">The function to call</param>
            <param name="args">Argument array</param>
            <param name="argsTuple">Tuple with extra arguments</param>
            <returns>The result of calling the function "func"</returns>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.CallWithKeywordArgs(Microsoft.Scripting.Runtime.CodeContext,System.Object,System.Object[],System.String[])">
            <summary>
            Calls the function with arguments, some of which are keyword arguments.
            </summary>
            <param name="context"></param>
            <param name="func">Function to call</param>
            <param name="args">Argument array</param>
            <param name="names">Names for some of the arguments</param>
            <returns>The result of calling the function "func"</returns>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.ParseSourceCode(Microsoft.Scripting.CompilerContext)">
            <summary>
            Parses the source code within a specified compiler context. 
            The source unit to parse is held on by the context.
            </summary>
            <param name="context">Compiler context.</param>
            <returns><b>null</b> on failure.</returns>
            <remarks>Could also set the code properties and line/file mappings on the source unit.</remarks>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.LanguageContext.ContextId">
            <summary>
            Provides the ContextId which includes members that should only be shown for this LanguageContext.
            
            ContextId's are used for filtering by Scope's.
            
            TODO: Not virtual, TestContext currently depends on being able to override.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.LanguageContext.DomainManager">
            <summary>
            Gets the ScriptDomainManager that this LanguageContext is running within.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.LanguageContext.CanCreateSourceCode">
            <summary>
            Whether the language can parse code and create source units.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.TryFlowResult">
            <summary>
            The structure to capture the result of the control flow for the
            try statement code generation.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.TryFlowResult._break">
            <summary>
            There is a top level "break" in the analyzed statement.
            Breaks nested in "switch" or loops do not count because they
            do not exit the block of code being analyzed.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.TryFlowResult._continue">
            <summary>
            There is a top level continue in the analyzed block.
            Continue statement nested in the loop doesn't count as it
            doesn't leave the block being analyzed.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.TryFlowResult._return">
            <summary>
            There is a return statement in the analyzed block.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.TryFlowResult._yield">
            <summary>
            There is a yield statement in the analyzed block of code.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.TryFlowAnalyzer">
            <summary>
            AST walker to analyze control flow for the try statement code generation.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.LambdaWalker">
            <summary>
            The walker will recurse into all statements/expressions,
            except for nested lambdas.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.TryFlowAnalyzer._result">
            <summary>
            Tracking the result of the analysis.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.TryFlowAnalyzer._nesting">
            <summary>
            Nested loops counter. We are only interested in
            control flow statements outside on the top level.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.TryFlowAnalyzer._switch">
            <summary>
            Nested switch statement counter. We are only interested
            in the top level "break" statement. One nested inside
            switch is fully contained.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DocumentationAttribute">
            <summary>
            Provides a mechanism for providing documentation stored in an assembly as metadata.  
            
            Applying this attribute will enable documentation to be provided to the user at run-time
            even if XML Docuementation files are unavailable.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DlrCachedCodeAttribute">
            <summary>
            An attribute that is applied to saved ScriptCode's to be used to re-create the ScriptCode
            from disk.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.OperationFailed">
            <summary>
            Singleton instance returned from an operator method when the operator method cannot provide a value.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.LocalSlot">
            <summary>
            Local variable access
            Note that access of local variables of an enclosing function is done using a FieldSlot
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Generation.LocalSlot.LocalBuilder">
            <summary>
            Gets the LocalBuilder that this Slot emits a local for
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.ContinueStatement">
            <summary>
            Breaks to the beginning of the the target LabeledStatement
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.TypeUtils.GetNumericConversionOrder(System.TypeCode,System.Int32@,System.Int32@)">
            <summary>
            Returns a numerical code of the size of a type.  All types get both a horizontal
            and vertical code.  Types that are lower in both dimensions have implicit conversions
            to types that are higher in both dimensions.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ExtensionMethodTracker">
            <summary>
            Represents extension method.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ExtensionMethodTracker._declaringType">
            <summary>
            The declaring type of the extension (the type this extension method extends)
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.ExtensionMethodTracker.DeclaringType">
            <summary>
            The declaring type of the extension method. Since this is an extension method,
            the declaring type is in fact the type this extension method extends,
            not Method.DeclaringType
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComDispatch.VariantBuilder">
            <summary>
            VariantBuilder handles packaging of arguments into a Variant for a call to IDispatch.Invoke
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComDispatch.Variant">
            <summary>
            Variant is the basic COM type for late-binding. It can contain any other COM data type.
            This type definition precisely matches the unmanaged data layout so that the struct can be passed
            to and from COM calls.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.Variant.IsPrimitiveType(System.Runtime.InteropServices.VarEnum)">
            <summary>
            Primitive types are the basic COM types. It includes valuetypes like ints, but also reference tyeps
            like BStrs. It does not include composite types like arrays and user-defined COM types (IUnknown/IDispatch).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.Variant.ToObject">
            <summary>
            Get the managed object representing the Variant.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.Variant.Clear">
            <summary>
            Release any unmanaged memory associated with the Variant
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.ComRuntimeHelpers.GetITypeInfoFromIDispatch(Microsoft.Scripting.Actions.ComDispatch.IDispatch,System.Boolean)">
            <summary>
            Look for typeinfo using IDispatch.GetTypeInfo
            </summary>
            <param name="dispatch"></param>
            <param name="throwIfMissingExpectedTypeInfo">
            Some COM objects just dont expose typeinfo. In these cases, this method will return null.
            Some COM objects do intend to expose typeinfo, but may not be able to do so if the type-library is not properly 
            registered. This will be considered as acceptable or as an error condition depending on throwIfMissingExpectedTypeInfo</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.ComRuntimeHelpers.CheckIfMissingTypeInfoIsExpected(System.Int32,System.Boolean)">
            <summary>
            This method should be called when typeinfo is not available for an object. The function
            will check if the typeinfo is expected to be missing. This can include error cases where
            the same error is guaranteed to happen all the time, on all machines, under all circumstances.
            In such cases, we just have to operate without the typeinfo.
            
            However, if accessing the typeinfo is failing in a transient way, we might want to throw
            an exception so that we will eagerly predictably indicate the problem.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComDispatch.ComRuntimeHelpers.UnsafeMethods">
            <summary>
            This class contains methods that either cannot be expressed in C#, or which require writing unsafe code.
            Callers of these methods need to use them extremely carefully as incorrect use could cause GC-holes
            and other problems.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.ComRuntimeHelpers.UnsafeMethods.AssertByrefPointsToStack(System.IntPtr)">
            <summary>
            TODO: Used only in DEBUG build. Remove?
            
            Ensure that "value" is a local variable in some caller's frame. So converting
            the byref to an IntPtr is a safe operation. Alternatively, we could also allow 
            allowed "value"  to be a pinned object.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComDispatch.ComRuntimeHelpers.UnsafeMethods.IUnknownReleaseDelegate">
            <summary>
            We will emit an indirect call to an unmanaged function pointer from the vtable of the given interface pointer. 
            This approach can take only ~300 instructions on x86 compared with ~900 for Marshal.Release. We are relying on 
            the JIT-compiler to do pinvoke-stub-inlining and calling the pinvoke target directly.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComDispatch.ComRuntimeHelpers.UnsafeMethods.IDispatchInvokeDelegate">
            <summary>
            We will emit an indirect call to an unmanaged function pointer from the vtable of the given IDispatch interface pointer. 
            It is not possible to express this in C#. Using an indirect pinvoke call allows us to do our own marshalling. 
            We can allocate the Variant arguments cheaply on the stack. We are relying on the JIT-compiler to do 
            pinvoke-stub-inlining and calling the pinvoke target directly.
            The alternative of calling via a managed interface declaration of IDispatch would have a performance
            penalty of going through a CLR stub that would have to re-push the arguments on the stack, etc.
            Marshal.GetDelegateForFunctionPointer could be used here, but its too expensive (~2000 instructions on x86).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.IOUtils.SeekLine(System.IO.TextReader,System.Int32)">
            <summary>
            Seeks the first character of a specified line in the text stream.
            Assumes the reader is currently positioned just before the first character of the first line.
            Line numbers are counted starting from 1.
            Returns <c>true</c> if the line is found (the current position of the reader will be  
            character read from the reader will be the first one of the line - if there is any), <b>false</b> otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.IOUtils.ReadTo(System.IO.TextReader,System.Char)">
            <summary>
            Reads characters to a string until end position or a terminator is reached. 
            Doesn't include the terminator into the resulting string.
            Returns <c>null</c>, if the reader is at the end position.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.IOUtils.SeekTo(System.IO.TextReader,System.Char)">
            <summary>
            Reads characters until end position or a terminator is reached.
            Returns <c>true</c> if the character has been found (the reader is positioned right behind the character), 
            <c>false</c> otherwise.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.Error">
            <summary>
               Strongly-typed and parameterized exception factory.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.ArgumentCannotBeOfTypeVoid">
            <summary>
            ArgumentException with message like "Argument type cannot be System.Void."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.ArgumentMustBeInteger">
            <summary>
            ArgumentException with message like "Argument must be of an integer type"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.UserDefinedOperatorMustBeStatic(System.Object)">
            <summary>
            ArgumentException with message like "User-defined operator method '{0}' must be static."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.UserDefinedOperatorMustNotBeVoid(System.Object)">
            <summary>
            ArgumentException with message like "User-defined operator method '{0}' must not be void."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.MethodContainsGenericParameters(System.Object)">
            <summary>
            ArgumentException with message like "Method {0} contains generic parameters"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.MethodIsGeneric(System.Object)">
            <summary>
            ArgumentException with message like "Method {0} is a generic method definition"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.OperandTypesDoNotMatchParameters(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "The operands for operator '{0}' do not match the parameters of method '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.IncorrectNumberOfMethodCallArguments(System.Object)">
            <summary>
            ArgumentException with message like "Incorrect number of arguments supplied for call to method '{0}'"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.UnaryOperatorNotDefined(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "The unary operator {0} is not defined for the type '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.BinaryOperatorNotDefined(System.Object,System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "The binary operator {0} is not defined for the types '{1}' and '{2}'."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.MethodDoesNotExistOnType(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "No method '{0}' exists on type '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.MethodWithArgsDoesNotExistOnType(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "No method '{0}' on type '{1}' is compatible with the supplied arguments."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.MethodWithMoreThanOneMatch(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "More than one method '{0}' on type '{1}' is compatible with the supplied arguments."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.ArgumentMustBeArray">
            <summary>
            ArgumentException with message like "Argument must be array"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.IncorrectNumberOfIndexes">
            <summary>
            ArgumentException with message like "Incorrect number of indexes"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.ArgumentMustBeArrayIndexType">
            <summary>
            ArgumentException with message like "Argument for array index must be of type Int32"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.LogicalOperatorMustHaveConsistentTypes(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "The user-defined operator method '{1}' for operator '{0}' must have identical parameter and return types."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.LogicalOperatorMustHaveBooleanOperators(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "The user-defined operator method '{1}' for operator '{0}' must have associated boolean True and False operators."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.ExpressionTypeCannotInitializeArrayType(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "An expression of type '{0}' cannot be used to initialize an array of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.IncorrectTypeForTypeAs(System.Object)">
            <summary>
            ArgumentException with message like "The type used in TypeAs Expression must be of reference or nullable type, {0} is neither"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.UnhandledUnary(System.Object)">
            <summary>
            ArgumentException with message like "Unhandled unary: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.CoercionOperatorNotDefined(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "No coercion operator is defined between types '{0}' and '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.ArgumentMustBeSingleDimensionalArrayType">
            <summary>
            ArgumentException with message like "Argument must be single dimensional array type"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.UnhandledBinary(System.Object)">
            <summary>
            ArgumentException with message like "Unhandled binary: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.CoalesceUsedOnNonNullType">
            <summary>
            InvalidOperationException with message like "Coalesce used with type that cannot be null"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.ArgumentTypesMustMatch">
            <summary>
            ArgumentException with message like "Argument types do not match"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.MethodNotPropertyAccessor(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "The method '{0}.{1}' is not a property accessor"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.NotAMemberOfType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "'{0}' is not a member of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.MemberNotFieldOrProperty(System.Object)">
            <summary>
            ArgumentException with message like "Member '{0}' not field or property"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.FieldNotDefinedForType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Field '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.PropertyDoesNotHaveGetter(System.Object)">
            <summary>
            ArgumentException with message like "The property '{0}' has no 'get' accessor"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.PropertyNotDefinedForType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Property '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Error.ArgumentMustBeBoolean">
            <summary>
            ArgumentException with message like "Argument must be boolean"
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.DictionaryUnionEnumerator">
            <summary>
            Presents a flat enumerable view of multiple dictionaries
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.PropertyMethodAttribute">
            <summary>
            Represents an ops-extension method which is used to implement a property.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.GlobalVariableExpression">
            <summary>
            Represents a variable accessed from the host's scope
            Note: this node isn't reducible; it needs a tree rewrite to work
            See GlobalsRewriter
            
            TODO: move to Microsoft.Scripting !!!
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.GlobalVariableExpression.IsLocal">
            <summary>
            If using dynamic lookup, indicates that the variable should be
            looked up in the innermost Scope rather than the top level scope
            
            TODO: Python specific, can it be removed?
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayIndex``1(System.Collections.Generic.IList{``0},System.Int32,System.String)">
            <summary>
            Requires the specified index to point inside the array.
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is outside the array.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayInsertIndex``1(System.Collections.Generic.IList{``0},System.Int32,System.String)">
            <summary>
            Requires the specified index to point inside the array or at the end
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is outside the array.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayRange``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayRange(System.String,System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentNullException">String is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresNotNullItems``1(System.Collections.Generic.IList{``0},System.String)">
            <summary>
            Requires the array and all its items to be non-null.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ArrayUtils.ToArray``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Converts a generic ICollection of T into an array of T.  
            
            If the collection is already an  array of T the original collection is returned.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.NotNullAttribute">
            <summary>
            This attribute marks a parameter that is not allowed to be null.
            It is used by the method binding infrastructure to generate better error 
            messages and method selection.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ExtensionTypeAttribute">
            <summary>
            Marks a class in the assembly as being an extension type for another type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ExtensionTypeAttribute.#ctor(System.Type,System.Type)">
            <summary>
            Marks a type in the assembly as being an extension type for another type.
            </summary>
            <param name="extends">The type which is being extended</param>
            <param name="extensionType">The type which provides the extension members.</param>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ExtensionTypeAttribute.ExtensionType">
            <summary>
            The type which contains extension members which are added to the type being extended.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ExtensionTypeAttribute.Extends">
            <summary>
            The type which is being extended by the extension type.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.SourceSpan">
            <summary>
            Stores the location of a span of text in a source file.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SourceSpan.#ctor(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Constructs a new span with a specific start and end location.
            </summary>
            <param name="start">The beginning of the span.</param>
            <param name="end">The end of the span.</param>
        </member>
        <member name="F:Microsoft.Scripting.SourceSpan.None">
            <summary>
            A valid span that represents no location.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceSpan.Invalid">
            <summary>
            An invalid span.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SourceSpan.op_Equality(Microsoft.Scripting.SourceSpan,Microsoft.Scripting.SourceSpan)">
            <summary>
            Compares two specified Span values to see if they are equal.
            </summary>
            <param name="left">One span to compare.</param>
            <param name="right">The other span to compare.</param>
            <returns>True if the spans are the same, False otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.SourceSpan.op_Inequality(Microsoft.Scripting.SourceSpan,Microsoft.Scripting.SourceSpan)">
            <summary>
            Compares two specified Span values to see if they are not equal.
            </summary>
            <param name="left">One span to compare.</param>
            <param name="right">The other span to compare.</param>
            <returns>True if the spans are not the same, False otherwise.</returns>
        </member>
        <member name="P:Microsoft.Scripting.SourceSpan.Start">
            <summary>
            The start location of the span.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceSpan.End">
            <summary>
            The end location of the span. Location of the first character behind the span.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceSpan.Length">
            <summary>
            Length of the span (number of characters inside the span).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceSpan.IsValid">
            <summary>
            Whether the locations in the span are valid.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.None">
            <summary>
            Gives us a concrete Type object to represent null's to allow for more uniform
            handling of methods that expect a Type or Type[].  This type can also be used by
            languages that support methods on null objects by adding extension methods with a
            Null/None this.
            
            TODO Should be renamed to Null to reflect the standard .NET name rather than Python name
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.None.#ctor">
            <summary>
            Private constructor is never called since 'null' is the only valid instance.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.VariableBinder">
            <summary>
            The base class for LambdaBinder and RuleBinder.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.VariableBinder.Bind(Microsoft.Scripting.Ast.LambdaExpression)">
            <summary>
            LambdaBinder entry point.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.VariableBinder.Reference(Microsoft.Scripting.Ast.Expression)">
            <summary>
            Called when a variable is referenced inside the current lambda.
            
            If the variable is defined on an outer lambda:
              1. Mark the current lambda and lambdas between as closures
              2. Mark the variable as lifted
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.VariableBinder.BindTheScopes">
            <summary>
            Post processing of the tree:
              1. Lift all locals to environment if necessary (generators,
                 lambdas marked with EmitLocalDictionary, etc)
              2. Group variables into lifted, locals, and globals
              3. Finally, create a ScopeInfos for each scope we encountered
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Constructor">
            <summary> Specifies that the member is a constructor, representing a ConstructorTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Event">
            <summary> Specifies that the member is an event, representing a EventTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Field">
            <summary> Specifies that the member is a field, representing a FieldTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Method">
            <summary> Specifies that the member is a method, representing a MethodTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Property">
            <summary> Specifies that the member is a property, representing a PropertyTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Type">
            <summary> Specifies that the member is a property, representing a TypeTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Namespace">
            <summary> Specifies that the member is a namespace, representing a NamespaceTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.MethodGroup">
            <summary> Specifies that the member is a group of method overloads, representing a MethodGroup</summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.TypeGroup">
            <summary> Specifies that the member is a group of types that very by arity, representing a TypeGroup</summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Custom">
            <summary> Specifies that the member is a custom meber, represetning a CustomTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Bound">
            <summary> Specifies that the member is a bound to an instance, representing a BoundMemberTracker</summary>        
        </member>
        <member name="T:Microsoft.Scripting.Actions.ActionBinder">
            <summary>
            Provides binding semantics for a language.  This include conversions as well as support
            for producing rules for actions.  These optimized rules are used for calling methods, 
            performing operators, and getting members using the ActionBinder's conversion semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.MakeRule``1(Microsoft.Scripting.Actions.DynamicAction,System.Object[])">
            <summary>
            Produces a rule for the specified Action for the given arguments.
            </summary>
            <typeparam name="T">The type of the DynamicSite the rule is being produced for.</typeparam>
            <param name="action">The Action that is being performed.</param>
            <param name="args">The arguments to the action as provided from the call site at runtime.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.Convert(System.Object,System.Type)">
            <summary>
            Converts an object at runtime into the specified type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.CanConvertFrom(System.Type,System.Type,Microsoft.Scripting.Generation.NarrowingLevel)">
            <summary>
            Determines if a conversion exists from fromType to toType at the specified narrowing level.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.SelectBestConversionFor(System.Type,System.Type,System.Type,Microsoft.Scripting.Generation.NarrowingLevel)">
            <summary>
            Selects the best (of two) candidates for conversion from actualType
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.PreferConvert(System.Type,System.Type)">
            <summary>
            Provides ordering for two parameter types if there is no conversion between the two parameter types.
            
            Returns true to select t1, false to select t2.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.ConvertExpression(Microsoft.Scripting.Ast.Expression,System.Type,Microsoft.Scripting.Ast.Expression)">
            <summary>
            Converts the provided expression to the given type.  The expression is safe to evaluate multiple times.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.GetByRefArray(System.Object[])">
            <summary>
            Gets the return value when an object contains out / by-ref parameters.  
            </summary>
            <param name="args">The values of by-ref and out parameters that the called method produced.  This includes the normal return
            value if the method does not return void.</param>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.GetMember(Microsoft.Scripting.Actions.DynamicAction,System.Type,System.String)">
            <summary>
            Gets the members that are visible from the provided type of the specified name.
            
            The default implemetnation first searches the type, then the flattened heirachy of the type, and then
            registered extension methods.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.MakeStaticAssignFromDerivedTypeError(System.Type,Microsoft.Scripting.Actions.MemberTracker,Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Ast.Expression)">
            <summary>
            Called when a set is attempting to assign to a field or property from a derived class through the base class.
            
            The default behavior is to allow the assignment.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.MakeStaticPropertyInstanceAccessError(Microsoft.Scripting.Actions.PropertyTracker,System.Boolean,System.Collections.Generic.IList{Microsoft.Scripting.Ast.Expression})">
            <summary>
            Creates an ErrorInfo object when a static property is accessed from an instance member.  The default behavior is throw
            an exception indicating that static members properties be accessed via an instance.  Languages can override this to 
            customize the exception, message, or to produce an ErrorInfo object which reads or writes to the property being accessed.
            </summary>
            <param name="tracker">The static property being accessed through an instance</param>
            <param name="isAssignment">True if the user is assigning to the property, false if the user is reading from the property</param>
            <param name="parameters">The parameters being used to access the property.  This includes the instance as the first entry, any index parameters, and the
            value being assigned as the last entry if isAssignment is true.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.MakeMissingMemberError(System.Type,System.String)">
            <summary>
            Provides a way for the binder to provide a custom error message when lookup fails.  Just
            doing this for the time being until we get a more robust error return mechanism.
            
            Deprecated, use the non-generic version instead
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.MakeReadOnlyMemberError``1(Microsoft.Scripting.Actions.RuleBuilder{``0},System.Type,System.String)">
            <summary>
            Provides a way for the binder to provide a custom error message when lookup fails.  Just
            doing this for the time being until we get a more robust error return mechanism.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.MakeUndeletableMemberError``1(Microsoft.Scripting.Actions.RuleBuilder{``0},System.Type,System.String)">
            <summary>
            Provides a way for the binder to provide a custom error message when lookup fails.  Just
            doing this for the time being until we get a more robust error return mechanism.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.GetAllExtensionMembers(System.Type,System.String)">
            <summary>
            Gets the extension members of the given name from the provided type.  Base classes are also
            searched for their extension members.  Once any of the types in the inheritance hierarchy
            provide an extension member the search is stopped.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.GetExtensionMembers(System.Type,System.String)">
            <summary>
            Gets the extension members of the given name from the provided type.  Subclasses of the
            type and their extension members are not searched.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.ReturnMemberTracker(System.Type,Microsoft.Scripting.Actions.MemberTracker)">
            <summary>
            Provides an opportunity for languages to replace all MemberInfo's with their own type.
            
            Alternatlely a language can expose MemberInfo's directly.
            </summary>
            <param name="memberTracker">The member which is being returned to the user.</param>
            <param name="type">Tthe type which the memberTrack was accessed from</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.MakeCallExpression(Microsoft.Scripting.Ast.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IList{Microsoft.Scripting.Ast.Expression})">
            <summary>
            Builds an expressoin for a call to the provided method using the given expressions.  If the
            method is not static the first parameter is used for the instance.
            
            Parameters are converted using the binder's conversion rules.
            
            If an incorrect number of parameters is provided MakeCallExpression returns null.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ContextId">
            <summary>
            Represents a language context.  Typically there is at most 1 context 
            associated with each language, but some languages may use more than one context
            to identify code that should be treated differently.  Contexts are used during
            member and operator lookup.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ContextId.RegisterContext(System.Object)">
            <summary>
            Registers a language within the system with the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ContextId.LookupContext(System.Object)">
            <summary>
            Looks up the context ID for the specified context identifier
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Generation.Snippets.SnippetsDirectory">
            <summary>
            Directory where snippet assembly will be saved if SaveSnippets is set.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Generation.Snippets.SnippetsFileName">
            <summary>
            Name of the snippet assembly (w/o extension).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Generation.Snippets.SaveSnippets">
            <summary>
            Save snippets to an assembly (see also SnippetsDirectory, SnippetsFileName).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Generation.Snippets.ILDebug">
            <summary>
            Write IL to a text file as it is generated.
            This flag can be changed any time.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptDomainManager.GetLanguageContext(System.Type)">
            <summary>
            Throws an exception on failure.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/></exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/></exception>
            <exception cref="T:Microsoft.Scripting.Runtime.MissingTypeException"><paramref name="languageId"/></exception>
            <exception cref="T:Microsoft.Scripting.Runtime.InvalidImplementationException">The language context's implementation failed to instantiate.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptDomainManager.GetLanguageContext``1">
            <summary>
            Gets the language context of the specified type.  This can be used by language implementors
            to get their LanguageContext for an already existing ScriptDomainManager.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptDomainManager.TryGetLanguageContext(System.String,Microsoft.Scripting.Runtime.LanguageContext@)">
            <exception cref="T:System.ArgumentNullException"><paramref name="languageId"/></exception>
            <exception cref="T:Microsoft.Scripting.Runtime.MissingTypeException"><paramref name="languageId"/></exception>
            <exception cref="T:Microsoft.Scripting.Runtime.InvalidImplementationException">The language context's implementation failed to instantiate.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptDomainManager.GetLanguageContexts(System.Boolean)">
            <exception cref="T:Microsoft.Scripting.Runtime.MissingTypeException"><paramref name="languageId"/></exception>
            <exception cref="T:Microsoft.Scripting.Runtime.InvalidImplementationException">The language context's implementation failed to instantiate.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptDomainManager.UseModule(System.String)">
            <summary>
            Uses the hosts search path and semantics to resolve the provided name to a SourceUnit.
            
            If the host provides a SourceUnit which is equal to an already loaded SourceUnit the
            previously loaded module is returned.
            
            Returns null if a module could not be found.
            </summary>
            <param name="name">an opaque parameter which has meaning to the host.  Typically a filename without an extension.</param>
            <exception cref="T:System.IO.FileNotFoundException">No file matches the specified name.</exception>
            <exception cref="T:System.ArgumentNullException">Name is a <c>null</c> reference.</exception>
            <exception cref="T:System.ArgumentException">Name is not valid.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptDomainManager.UseModule(System.String,System.String)">
            <summary>
            Requests a SourceUnit from the provided path and compiles it to a ScriptScope.
            
            If the host provides a SourceUnit which is equal to an already loaded SourceUnit the
            previously loaded module is returned.
            
            Returns null if a module could not be found.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/></exception>
            <exception cref="T:System.ArgumentException">no language registered</exception>
            <exception cref="T:Microsoft.Scripting.Runtime.MissingTypeException"><paramref name="languageId"/></exception>
            <exception cref="T:Microsoft.Scripting.Runtime.InvalidImplementationException">The language provider's implementation failed to instantiate.</exception>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ScriptDomainManager.Globals">
            <summary>
            A collection of environment variables.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ScriptDomainManager.LanguageRegistration">
            <summary>
            Singleton for each language.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptDomainManager.LanguageRegistration.LoadLanguageContext">
            <summary>
            Must not be called under a lock as it can potentially call a user code.
            </summary>
            <exception cref="T:Microsoft.Scripting.Runtime.MissingTypeException"><paramref name="languageId"/></exception>
            <exception cref="T:Microsoft.Scripting.Runtime.InvalidImplementationException">The language context's implementation failed to instantiate.</exception>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ExceptionHelpers">
            <summary>
            These are some generally useful helper methods for handling exceptions.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ExceptionHelpers._caughtExceptions">
            <summary>
            Keeps track of exceptions being handled in interpreted mode (so we can support rethrow statements).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ExceptionHelpers.UpdateForRethrow(System.Exception)">
            <summary>
            Updates an exception before it's getting re-thrown so
            we can present a reasonable stack trace to the user.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ExceptionHelpers.GetExceptionStackTraces(System.Exception)">
            <summary>
            Returns all the stack traces associates with an exception
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ExceptionHelpers.GetStackFrames(System.Exception)">
            <summary>
            Walks all stack frames, filtering out DLR frames
            Does not walk the frames in the InnerException, if any
            Frames are returned in CLR order (inner to outer)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ExceptionHelpers.GetStackFrames(System.Exception,System.Boolean)">
            <summary>
            Walks all stack frames, filtering out DLR frames
            Does not walk the frames in the InnerException, if any
            Frames are returned in CLR order (inner to outer), unless reverse is set
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ExceptionHelpers.CurrentExceptions">
            <summary>
            Gets the list of exceptions that are currently being handled by the user. 
            
            These represent active catch blocks on the stack.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.MultiRuntimeAwareAttribute">
            <summary>
            marks a field, class, or struct as being safe to have statics which can be accessed
            from multiple runtimes.
            
            Static fields which are not read-only or marked with this attribute will be flagged 
            by a test which looks for state being shared between runtimes.  Before applying this
            attribute you should ensure that it is safe to share the state.  This is typically
            state which is lazy initialized or state which is caching values which are identical
            in all runtimes and are immutable.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.DynamicSiteTarget`2">
            <summary>
            Dynamic site delegate type - arity 1
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.DynamicSiteTarget`3">
            <summary>
            Dynamic site delegate type - arity 2
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.DynamicSiteTarget`4">
            <summary>
            Dynamic site delegate type - arity 3
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.DynamicSiteTarget`5">
            <summary>
            Dynamic site delegate type - arity 4
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.DynamicSiteTarget`6">
            <summary>
            Dynamic site delegate type - arity 5
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.DynamicSiteTarget`7">
            <summary>
            Dynamic site delegate type - arity 6
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.DynamicSiteTarget`8">
            <summary>
            Dynamic site delegate type - arity 7
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.DynamicSiteTarget`9">
            <summary>
            Dynamic site delegate type - arity 8
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.DynamicSiteTarget`10">
            <summary>
            Dynamic site delegate type - arity 9
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.AbstractValue">
            <summary>
            An abstraction of an actual value
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.TryStatementInfo._target">
            <summary>
            The entry point into the try statement
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.TryStatementInfo._yieldInCatch">
            <summary>
            One or more of the catch blocks includes yield.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.TryStatementInfo._tryYields">
            <summary>
            Labels for the yields inside a try block.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.TryStatementInfo._catchYields">
            <summary>
            Labels for the yields inside the catch clause.
            This is only valid for the try statement with a 'finally' clause,
            in which case we need to enter the outer try, and then dispatch
            to the yield labels
            For try statement without finally, the yields contained within
            catch are hoisted outside of the try and as such don't need
            to be tracked
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.TryStatementInfo._finallyYields">
            <summary>
            Labels for the yields inside a finally block.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.TryStatementInfo._catchYieldsFlags">
            <summary>
            For each catch block we have flag whether this block yields.
            This is a parallel array to the TryStatement.Handlers
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Annotations.Add``1(``0)">
            <summary>
            Creates a clone of annotations and adds the value into the clone
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Annotations.Remove``1">
            <summary>
            Returns clone with annotation(s) of type T removed
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.CustomTracker">
            <summary>
            A custom member tracker which enables languages to plug in arbitrary
            members into the lookup process.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.ComTypeLibDesc.CreateFromGuid(System.Guid)">
            <summary>
            Reads the latest registered type library for the corresponding GUID,
            reads definitions of CoClass'es and Enum's from this library
            and creates a IDynamicObject that allows to instantiate coclasses
            and get actual values for the enums.
            </summary>
            <param name="typeLibGuid">Type Library Guid</param>
            <returns>ComTypeLibDesc object</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ComDispatch.ComTypeLibDesc.CreateFromObject(System.Object)">
            <summary>
            Gets an ITypeLib object from OLE Automation compatible RCW ,
            reads definitions of CoClass'es and Enum's from this library
            and creates a IDynamicObject that allows to instantiate coclasses
            and get actual values for the enums.
            </summary>
            <param name="rcw">OLE automation compatible RCW</param>
            <returns>ComTypeLibDesc object</returns>
        </member>
        <member name="T:Microsoft.Scripting.Utils.StrongBox`1">
            <summary>
            Microsoft.Scripting version of System.Runtime.CompilerServices.StrongBox.
            
            To be removed when merged with CLR v3.5.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Utils.StrongBox`1.Value">
            <summary>
            Gets the strongly typed value associated with the StrongBox.  This is explicitly
            exposed as a field instead of a property to enable loading the address of the field.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.StrongBox`1.#ctor">
            <summary>
            Creates a new StrongBox which can receive a value when used in a reference call.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.StrongBox`1.#ctor(`0)">
            <summary>
            Creates a new StrongBox with the specified value.
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.PositionTrackingWriter">
            <summary>
            Efficiently tracks (line,column) information as text is added, and
            collects line mappings between the original and generated source code
            so we can generate correct debugging information later
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.PositionTrackingWriter.MapLocation(System.CodeDom.CodeLinePragma)">
            <summary>
            Marks the current position of the writer as corresponding to the
            original location passed in
            </summary>
            <param name="linePragma">the line pragma corresponding to the 
            current position in the generated code</param>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ScriptDomainOptions.DebugMode">
            <summary>
            Whether the application is in debug mode.
            This means:
            
            1) Symbols are emitted for debuggable methods (methods associated with SourceUnit).
            2) Debuggable methods are emitted to non-collectable types (this is due to CLR limitations on dynamic method debugging).
            3) JIT optimization is disabled for all methods
            4) Languages may disable optimizations based on this value.
            
            TODO: host visible, move to ScriptRuntime
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ScriptDomainOptions.PrivateBinding">
            <summary>
            Ignore CLR visibility checks.
            TODO: host visible, move to ScriptRuntime
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ScriptDomainOptions.Frames">
            <summary>
            Generate functions using custom frames. Allocate the locals on frames.
            When custom frames are turned on, we emit dictionaries everywhere
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ScriptDomainOptions.LightweightScopes">
            <summary>
            Generate optimized scopes that can be garbage collected
            (globals are stored in an array instead of static fields on a
            generated type)
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ScriptDomainOptions.ShowTrees">
            <summary>
            Print generated Abstract Syntax Trees to the console
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ScriptDomainOptions.DumpTrees">
            <summary>
            Write out generated Abstract Syntax Trees as files in the current directory
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ScriptDomainOptions.ShowRules">
            <summary>
            Print generated action dispatch rules to the console
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ScriptDomainOptions.ShowScopes">
            <summary>
            Print the scopes and closures that get generated by the compiler
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ScriptDomainOptions.CachePointersInApartment">
            <summary>
            An RCW object represents a COM object which could potentially be in another apartment. So access
            to the COM interface pointer needs to be done in an apartment-safe way. Marshal.GetIDispatchForObject
            gives out the the appropriate interface pointer (and doing marshalling of the COM object to the current
            aparment if necessary). However, this is expensive and we would like to cache the returned interface pointer.
            This is a prototype of the caching optimization. It is not ready for primte-time use. Currently, it will
            leak COM objects as it does not call Marshal.Release when it should.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ScriptDomainOptions.PreferComDispatchOverTypeInfo">
            <summary>
            Use pure IDispatch-based invocation when calling methods/properties
            on System.__ComObject
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.IndexSlot">
            <summary>
            Slot that indexes into an array
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.BinderType.Normal">
            <summary>
            The MethodBinder will perform normal method binding.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.BinderType.BinaryOperator">
            <summary>
            The MethodBinder will return the languages definition of NotImplemented if the arguments are
            incompatible with the signature.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.BinderType.Constructor">
            <summary>
            The MethodBinder will set properties/fields for unused keyword arguments on the instance 
            that gets returned from the method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.YieldLabelBuilder.ExceptionBlock.AddYieldTarget(Microsoft.Scripting.Ast.TargetLabel,System.Int32)">
            <summary>
            Adds yield target to the current try statement and returns the label
            to which the outer code must jump to to route properly to this label.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.AssignmentExpression">
            <summary>
            Represents assignment: Expression = Value. The left had side
            must be a valid lvalue:
              VariableExpression
              ParameterExpression
              MemberExpression with writable property/field
              BinaryExpression with NodeType == ArrayIndex
              (future) IndexedPropertyExpression
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.SourceUnitReader">
            <summary>
            Couples a source unit with an open text reader. Remotable (TextReader is a MBRO).
            </summary>    
        </member>
        <member name="T:Microsoft.Scripting.Ast.GeneratorInfo">
            <summary>
            GeneratorInfo is a data structure in which Compiler keeps information related co compiling
            GeneartorLambdaExpression. It's created by YieldLabelBuilder which is invoked by VariableBinder
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.GeneratorInfo._tryInfos">
            <summary>
            Try statements in this generator
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.GeneratorInfo._yieldTargets">
            <summary>
            Yield statements in this generator
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.GeneratorInfo._topTargets">
            <summary>
            The top targets for the generator dispatch.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.GeneratorInfo._temps">
            <summary>
            The generator temps required to generate the lambda
            
            These are not temporary variables visible in the tree, rather they
            are variables needed internally by code gen
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Ast.GeneratorInfo._nextTemp">
            <summary>
            The index of the next temp to hand out
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ErrorInfo">
            <summary>
            Encapsulates information about the result that should be produced when 
            a DynamicAction cannot be performed.  The ErrorInfo can hold one of:
                an expression which creates an Exception to be thrown 
                an expression which produces a value which should be returned 
                    directly to the user and represents an error has occured (for
                    example undefined in JavaScript)
                an expression which produces a value which should be returned
                    directly to the user but does not actually represent an error.
            
            ErrorInfo's are produced by an ActionBinder in response to a failed
            binding.  
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ErrorInfo.#ctor(Microsoft.Scripting.Ast.Expression,Microsoft.Scripting.Actions.ErrorInfo.ErrorInfoKind)">
            <summary>
            Private constructor - consumers must use static From* factories
            to create ErrorInfo objects.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ErrorInfo.FromException(Microsoft.Scripting.Ast.Expression)">
            <summary>
            Creates a new ErrorInfo which represents an exception that should
            be thrown.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ErrorInfo.FromValue(Microsoft.Scripting.Ast.Expression)">
            <summary>
            Creates a new ErrorInfo which represents a value which should be
            returned to the user.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ErrorInfo.FromValueNoError(Microsoft.Scripting.Ast.Expression)">
            <summary>
            Crates a new ErrorInfo which represents a value which should be returned
            to the user but does not represent an error.
            </summary>
            <param name="resultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ErrorInfo.MakeErrorForRule(Microsoft.Scripting.Actions.RuleBuilder,Microsoft.Scripting.Actions.ActionBinder)">
            <summary>
            Internal helper to produce the actual expression used for the error when emitting
            the error into a rule.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ErrorInfo.ErrorInfoKind.Exception">
            <summary>
            The ErrorInfo expression produces an exception
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ErrorInfo.ErrorInfoKind.Error">
            <summary>
            The ErrorInfo expression produces a value which represents the error (e.g. undefined)
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ErrorInfo.ErrorInfoKind.Success">
            <summary>
            The ErrorInfo expression produces a value which is not an error
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComDispatch.ComReferenceArgBuilder">
            <summary>
            This allows passing a COM type by reference, given a StrongBox of the managed type.
            ReferenceArgBuilder can be used when COM and the CLR agree on the data layout of the data type,
            like for integral types. However, strings for eg are represented as BSTR and System.String respectively
            in the two worlds. ReferenceArgBuilder cannot be used as is in such cases
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComDispatch.IDispatchMethodIndices">
            <summary>
            Layout of the IDispatch vtable
            </summary>
        </member>
    </members>
</doc>
